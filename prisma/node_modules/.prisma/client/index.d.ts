
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Localidad
 */

export type Localidad = {
  id: number
  nombre: string
}

/**
 * Model TipoCurso
 */

export type TipoCurso = {
  id: number
  nombre: string
  descripcion: string
}

/**
 * Model Curso
 */

export type Curso = {
  id: number
  nombre: string
  descripcion: string
  tipoCursoId: number
}

/**
 * Model LocalidadOnCurso
 */

export type LocalidadOnCurso = {
  cursoId: number
  localidadId: number
  nombreMostrar: string
  descripcion: string
}

/**
 * Model DestinatarioOnCurso
 */

export type DestinatarioOnCurso = {
  cursoId: number
  destinatarioId: number
  descripcion: string
  nombreMostrar: string
}

/**
 * Model AlumnoOnCursoActivo
 */

export type AlumnoOnCursoActivo = {
  cursoActivoId: number
  alumnoId: number
  descripcion: string
  nombreMostrar: string
}

/**
 * Model Alumno
 */

export type Alumno = {
  id: number
  nroDocumento: number
  apellido: string
  nombre: string
  fechaNacimiento: Date
  email: string
  celular: number
  domicilio: string
  barrio: string | null
  localidadId: number
}

/**
 * Model Destinatarios
 */

export type Destinatarios = {
  id: number
  nombre: string
}

/**
 * Model Salas
 */

export type Salas = {
  id: number
  nombre: string
  descripcion: string
  localidadId: number
}

/**
 * Model CursosActivos
 */

export type CursosActivos = {
  id: number
  nombreMostrar: string
  activo: boolean
  fechaInicio: Date
  fechaFin: Date
  horario: string
  cupos: number
  descripcion: string
  salaId: number | null
  localidadId: number | null
  cursoId: number | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Localidads
 * const localidads = await prisma.localidad.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Localidads
   * const localidads = await prisma.localidad.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.localidad`: Exposes CRUD operations for the **Localidad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Localidads
    * const localidads = await prisma.localidad.findMany()
    * ```
    */
  get localidad(): Prisma.LocalidadDelegate<GlobalReject>;

  /**
   * `prisma.tipoCurso`: Exposes CRUD operations for the **TipoCurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoCursos
    * const tipoCursos = await prisma.tipoCurso.findMany()
    * ```
    */
  get tipoCurso(): Prisma.TipoCursoDelegate<GlobalReject>;

  /**
   * `prisma.curso`: Exposes CRUD operations for the **Curso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursos
    * const cursos = await prisma.curso.findMany()
    * ```
    */
  get curso(): Prisma.CursoDelegate<GlobalReject>;

  /**
   * `prisma.localidadOnCurso`: Exposes CRUD operations for the **LocalidadOnCurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalidadOnCursos
    * const localidadOnCursos = await prisma.localidadOnCurso.findMany()
    * ```
    */
  get localidadOnCurso(): Prisma.LocalidadOnCursoDelegate<GlobalReject>;

  /**
   * `prisma.destinatarioOnCurso`: Exposes CRUD operations for the **DestinatarioOnCurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DestinatarioOnCursos
    * const destinatarioOnCursos = await prisma.destinatarioOnCurso.findMany()
    * ```
    */
  get destinatarioOnCurso(): Prisma.DestinatarioOnCursoDelegate<GlobalReject>;

  /**
   * `prisma.alumnoOnCursoActivo`: Exposes CRUD operations for the **AlumnoOnCursoActivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlumnoOnCursoActivos
    * const alumnoOnCursoActivos = await prisma.alumnoOnCursoActivo.findMany()
    * ```
    */
  get alumnoOnCursoActivo(): Prisma.AlumnoOnCursoActivoDelegate<GlobalReject>;

  /**
   * `prisma.alumno`: Exposes CRUD operations for the **Alumno** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alumnos
    * const alumnos = await prisma.alumno.findMany()
    * ```
    */
  get alumno(): Prisma.AlumnoDelegate<GlobalReject>;

  /**
   * `prisma.destinatarios`: Exposes CRUD operations for the **Destinatarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Destinatarios
    * const destinatarios = await prisma.destinatarios.findMany()
    * ```
    */
  get destinatarios(): Prisma.DestinatariosDelegate<GlobalReject>;

  /**
   * `prisma.salas`: Exposes CRUD operations for the **Salas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salas
    * const salas = await prisma.salas.findMany()
    * ```
    */
  get salas(): Prisma.SalasDelegate<GlobalReject>;

  /**
   * `prisma.cursosActivos`: Exposes CRUD operations for the **CursosActivos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CursosActivos
    * const cursosActivos = await prisma.cursosActivos.findMany()
    * ```
    */
  get cursosActivos(): Prisma.CursosActivosDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.30.3
   * Query Engine version: b8c35d44de987a9691890b3ddf3e2e7effb9bf20
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Localidad: 'Localidad',
    TipoCurso: 'TipoCurso',
    Curso: 'Curso',
    LocalidadOnCurso: 'LocalidadOnCurso',
    DestinatarioOnCurso: 'DestinatarioOnCurso',
    AlumnoOnCursoActivo: 'AlumnoOnCursoActivo',
    Alumno: 'Alumno',
    Destinatarios: 'Destinatarios',
    Salas: 'Salas',
    CursosActivos: 'CursosActivos'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Localidad
   */


  export type AggregateLocalidad = {
    _count: LocalidadCountAggregateOutputType | null
    count: LocalidadCountAggregateOutputType | null
    _avg: LocalidadAvgAggregateOutputType | null
    avg: LocalidadAvgAggregateOutputType | null
    _sum: LocalidadSumAggregateOutputType | null
    sum: LocalidadSumAggregateOutputType | null
    _min: LocalidadMinAggregateOutputType | null
    min: LocalidadMinAggregateOutputType | null
    _max: LocalidadMaxAggregateOutputType | null
    max: LocalidadMaxAggregateOutputType | null
  }

  export type LocalidadAvgAggregateOutputType = {
    id: number | null
  }

  export type LocalidadSumAggregateOutputType = {
    id: number | null
  }

  export type LocalidadMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type LocalidadMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type LocalidadCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type LocalidadAvgAggregateInputType = {
    id?: true
  }

  export type LocalidadSumAggregateInputType = {
    id?: true
  }

  export type LocalidadMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type LocalidadMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type LocalidadCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type LocalidadAggregateArgs = {
    /**
     * Filter which Localidad to aggregate.
     * 
    **/
    where?: LocalidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Localidads to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalidadOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LocalidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Localidads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Localidads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Localidads
    **/
    _count?: true | LocalidadCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | LocalidadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalidadAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: LocalidadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalidadSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: LocalidadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalidadMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: LocalidadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalidadMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: LocalidadMaxAggregateInputType
  }

  export type GetLocalidadAggregateType<T extends LocalidadAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalidad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalidad[P]>
      : GetScalarType<T[P], AggregateLocalidad[P]>
  }


    
    
  export type LocalidadGroupByArgs = {
    where?: LocalidadWhereInput
    orderBy?: Enumerable<LocalidadOrderByInput>
    by: Array<LocalidadScalarFieldEnum>
    having?: LocalidadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalidadCountAggregateInputType | true
    _avg?: LocalidadAvgAggregateInputType
    _sum?: LocalidadSumAggregateInputType
    _min?: LocalidadMinAggregateInputType
    _max?: LocalidadMaxAggregateInputType
  }


  export type LocalidadGroupByOutputType = {
    id: number
    nombre: string
    _count: LocalidadCountAggregateOutputType | null
    _avg: LocalidadAvgAggregateOutputType | null
    _sum: LocalidadSumAggregateOutputType | null
    _min: LocalidadMinAggregateOutputType | null
    _max: LocalidadMaxAggregateOutputType | null
  }

  type GetLocalidadGroupByPayload<T extends LocalidadGroupByArgs> = Promise<
    Array<
      PickArray<LocalidadGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof LocalidadGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], LocalidadGroupByOutputType[P]> 
            : GetScalarType<T[P], LocalidadGroupByOutputType[P]>
        }
      > 
    >


  export type LocalidadSelect = {
    id?: boolean
    nombre?: boolean
    alumnos?: boolean | AlumnoFindManyArgs
    salas?: boolean | SalasFindManyArgs
    cursos?: boolean | LocalidadOnCursoFindManyArgs
  }

  export type LocalidadInclude = {
    alumnos?: boolean | AlumnoFindManyArgs
    salas?: boolean | SalasFindManyArgs
    cursos?: boolean | LocalidadOnCursoFindManyArgs
  }

  export type LocalidadGetPayload<
    S extends boolean | null | undefined | LocalidadArgs,
    U = keyof S
      > = S extends true
        ? Localidad
    : S extends undefined
    ? never
    : S extends LocalidadArgs | LocalidadFindManyArgs
    ?'include' extends U
    ? Localidad  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'alumnos'
        ? Array < AlumnoGetPayload<S['include'][P]>>  :
        P extends 'salas'
        ? Array < SalasGetPayload<S['include'][P]>>  :
        P extends 'cursos'
        ? Array < LocalidadOnCursoGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Localidad ?Localidad [P]
  : 
          P extends 'alumnos'
        ? Array < AlumnoGetPayload<S['select'][P]>>  :
        P extends 'salas'
        ? Array < SalasGetPayload<S['select'][P]>>  :
        P extends 'cursos'
        ? Array < LocalidadOnCursoGetPayload<S['select'][P]>>  : never
  } 
    : Localidad
  : Localidad


  type LocalidadCountArgs = Merge<
    Omit<LocalidadFindManyArgs, 'select' | 'include'> & {
      select?: LocalidadCountAggregateInputType | true
    }
  >

  export interface LocalidadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Localidad that matches the filter.
     * @param {LocalidadFindUniqueArgs} args - Arguments to find a Localidad
     * @example
     * // Get one Localidad
     * const localidad = await prisma.localidad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocalidadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LocalidadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Localidad'> extends True ? CheckSelect<T, Prisma__LocalidadClient<Localidad>, Prisma__LocalidadClient<LocalidadGetPayload<T>>> : CheckSelect<T, Prisma__LocalidadClient<Localidad | null >, Prisma__LocalidadClient<LocalidadGetPayload<T> | null >>

    /**
     * Find the first Localidad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadFindFirstArgs} args - Arguments to find a Localidad
     * @example
     * // Get one Localidad
     * const localidad = await prisma.localidad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocalidadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LocalidadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Localidad'> extends True ? CheckSelect<T, Prisma__LocalidadClient<Localidad>, Prisma__LocalidadClient<LocalidadGetPayload<T>>> : CheckSelect<T, Prisma__LocalidadClient<Localidad | null >, Prisma__LocalidadClient<LocalidadGetPayload<T> | null >>

    /**
     * Find zero or more Localidads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Localidads
     * const localidads = await prisma.localidad.findMany()
     * 
     * // Get first 10 Localidads
     * const localidads = await prisma.localidad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localidadWithIdOnly = await prisma.localidad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocalidadFindManyArgs>(
      args?: SelectSubset<T, LocalidadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Localidad>>, PrismaPromise<Array<LocalidadGetPayload<T>>>>

    /**
     * Create a Localidad.
     * @param {LocalidadCreateArgs} args - Arguments to create a Localidad.
     * @example
     * // Create one Localidad
     * const Localidad = await prisma.localidad.create({
     *   data: {
     *     // ... data to create a Localidad
     *   }
     * })
     * 
    **/
    create<T extends LocalidadCreateArgs>(
      args: SelectSubset<T, LocalidadCreateArgs>
    ): CheckSelect<T, Prisma__LocalidadClient<Localidad>, Prisma__LocalidadClient<LocalidadGetPayload<T>>>

    /**
     * Create many Localidads.
     *     @param {LocalidadCreateManyArgs} args - Arguments to create many Localidads.
     *     @example
     *     // Create many Localidads
     *     const localidad = await prisma.localidad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocalidadCreateManyArgs>(
      args?: SelectSubset<T, LocalidadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Localidad.
     * @param {LocalidadDeleteArgs} args - Arguments to delete one Localidad.
     * @example
     * // Delete one Localidad
     * const Localidad = await prisma.localidad.delete({
     *   where: {
     *     // ... filter to delete one Localidad
     *   }
     * })
     * 
    **/
    delete<T extends LocalidadDeleteArgs>(
      args: SelectSubset<T, LocalidadDeleteArgs>
    ): CheckSelect<T, Prisma__LocalidadClient<Localidad>, Prisma__LocalidadClient<LocalidadGetPayload<T>>>

    /**
     * Update one Localidad.
     * @param {LocalidadUpdateArgs} args - Arguments to update one Localidad.
     * @example
     * // Update one Localidad
     * const localidad = await prisma.localidad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocalidadUpdateArgs>(
      args: SelectSubset<T, LocalidadUpdateArgs>
    ): CheckSelect<T, Prisma__LocalidadClient<Localidad>, Prisma__LocalidadClient<LocalidadGetPayload<T>>>

    /**
     * Delete zero or more Localidads.
     * @param {LocalidadDeleteManyArgs} args - Arguments to filter Localidads to delete.
     * @example
     * // Delete a few Localidads
     * const { count } = await prisma.localidad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocalidadDeleteManyArgs>(
      args?: SelectSubset<T, LocalidadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Localidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Localidads
     * const localidad = await prisma.localidad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocalidadUpdateManyArgs>(
      args: SelectSubset<T, LocalidadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Localidad.
     * @param {LocalidadUpsertArgs} args - Arguments to update or create a Localidad.
     * @example
     * // Update or create a Localidad
     * const localidad = await prisma.localidad.upsert({
     *   create: {
     *     // ... data to create a Localidad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Localidad we want to update
     *   }
     * })
    **/
    upsert<T extends LocalidadUpsertArgs>(
      args: SelectSubset<T, LocalidadUpsertArgs>
    ): CheckSelect<T, Prisma__LocalidadClient<Localidad>, Prisma__LocalidadClient<LocalidadGetPayload<T>>>

    /**
     * Count the number of Localidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadCountArgs} args - Arguments to filter Localidads to count.
     * @example
     * // Count the number of Localidads
     * const count = await prisma.localidad.count({
     *   where: {
     *     // ... the filter for the Localidads we want to count
     *   }
     * })
    **/
    count<T extends LocalidadCountArgs>(
      args?: Subset<T, LocalidadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalidadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Localidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalidadAggregateArgs>(args: Subset<T, LocalidadAggregateArgs>): PrismaPromise<GetLocalidadAggregateType<T>>

    /**
     * Group by Localidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalidadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalidadGroupByArgs['orderBy'] }
        : { orderBy?: LocalidadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalidadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalidadGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Localidad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LocalidadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    alumnos<T extends AlumnoFindManyArgs = {}>(args?: Subset<T, AlumnoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Alumno>>, PrismaPromise<Array<AlumnoGetPayload<T>>>>;

    salas<T extends SalasFindManyArgs = {}>(args?: Subset<T, SalasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Salas>>, PrismaPromise<Array<SalasGetPayload<T>>>>;

    cursos<T extends LocalidadOnCursoFindManyArgs = {}>(args?: Subset<T, LocalidadOnCursoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LocalidadOnCurso>>, PrismaPromise<Array<LocalidadOnCursoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Localidad findUnique
   */
  export type LocalidadFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
    /**
     * Throw an Error if a Localidad can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Localidad to fetch.
     * 
    **/
    where: LocalidadWhereUniqueInput
  }


  /**
   * Localidad findFirst
   */
  export type LocalidadFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
    /**
     * Throw an Error if a Localidad can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Localidad to fetch.
     * 
    **/
    where?: LocalidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Localidads to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalidadOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Localidads.
     * 
    **/
    cursor?: LocalidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Localidads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Localidads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Localidads.
     * 
    **/
    distinct?: Enumerable<LocalidadScalarFieldEnum>
  }


  /**
   * Localidad findMany
   */
  export type LocalidadFindManyArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
    /**
     * Filter, which Localidads to fetch.
     * 
    **/
    where?: LocalidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Localidads to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalidadOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Localidads.
     * 
    **/
    cursor?: LocalidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Localidads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Localidads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocalidadScalarFieldEnum>
  }


  /**
   * Localidad create
   */
  export type LocalidadCreateArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
    /**
     * The data needed to create a Localidad.
     * 
    **/
    data: XOR<LocalidadCreateInput, LocalidadUncheckedCreateInput>
  }


  /**
   * Localidad createMany
   */
  export type LocalidadCreateManyArgs = {
    data: Enumerable<LocalidadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Localidad update
   */
  export type LocalidadUpdateArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
    /**
     * The data needed to update a Localidad.
     * 
    **/
    data: XOR<LocalidadUpdateInput, LocalidadUncheckedUpdateInput>
    /**
     * Choose, which Localidad to update.
     * 
    **/
    where: LocalidadWhereUniqueInput
  }


  /**
   * Localidad updateMany
   */
  export type LocalidadUpdateManyArgs = {
    data: XOR<LocalidadUpdateManyMutationInput, LocalidadUncheckedUpdateManyInput>
    where?: LocalidadWhereInput
  }


  /**
   * Localidad upsert
   */
  export type LocalidadUpsertArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
    /**
     * The filter to search for the Localidad to update in case it exists.
     * 
    **/
    where: LocalidadWhereUniqueInput
    /**
     * In case the Localidad found by the `where` argument doesn't exist, create a new Localidad with this data.
     * 
    **/
    create: XOR<LocalidadCreateInput, LocalidadUncheckedCreateInput>
    /**
     * In case the Localidad was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LocalidadUpdateInput, LocalidadUncheckedUpdateInput>
  }


  /**
   * Localidad delete
   */
  export type LocalidadDeleteArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
    /**
     * Filter which Localidad to delete.
     * 
    **/
    where: LocalidadWhereUniqueInput
  }


  /**
   * Localidad deleteMany
   */
  export type LocalidadDeleteManyArgs = {
    where?: LocalidadWhereInput
  }


  /**
   * Localidad without action
   */
  export type LocalidadArgs = {
    /**
     * Select specific fields to fetch from the Localidad
     * 
    **/
    select?: LocalidadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadInclude | null
  }



  /**
   * Model TipoCurso
   */


  export type AggregateTipoCurso = {
    _count: TipoCursoCountAggregateOutputType | null
    count: TipoCursoCountAggregateOutputType | null
    _avg: TipoCursoAvgAggregateOutputType | null
    avg: TipoCursoAvgAggregateOutputType | null
    _sum: TipoCursoSumAggregateOutputType | null
    sum: TipoCursoSumAggregateOutputType | null
    _min: TipoCursoMinAggregateOutputType | null
    min: TipoCursoMinAggregateOutputType | null
    _max: TipoCursoMaxAggregateOutputType | null
    max: TipoCursoMaxAggregateOutputType | null
  }

  export type TipoCursoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoCursoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoCursoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type TipoCursoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type TipoCursoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type TipoCursoAvgAggregateInputType = {
    id?: true
  }

  export type TipoCursoSumAggregateInputType = {
    id?: true
  }

  export type TipoCursoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type TipoCursoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type TipoCursoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type TipoCursoAggregateArgs = {
    /**
     * Filter which TipoCurso to aggregate.
     * 
    **/
    where?: TipoCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TipoCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoCursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoCursos
    **/
    _count?: true | TipoCursoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TipoCursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoCursoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TipoCursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoCursoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TipoCursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoCursoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TipoCursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoCursoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TipoCursoMaxAggregateInputType
  }

  export type GetTipoCursoAggregateType<T extends TipoCursoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoCurso[P]>
      : GetScalarType<T[P], AggregateTipoCurso[P]>
  }


    
    
  export type TipoCursoGroupByArgs = {
    where?: TipoCursoWhereInput
    orderBy?: Enumerable<TipoCursoOrderByInput>
    by: Array<TipoCursoScalarFieldEnum>
    having?: TipoCursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoCursoCountAggregateInputType | true
    _avg?: TipoCursoAvgAggregateInputType
    _sum?: TipoCursoSumAggregateInputType
    _min?: TipoCursoMinAggregateInputType
    _max?: TipoCursoMaxAggregateInputType
  }


  export type TipoCursoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    _count: TipoCursoCountAggregateOutputType | null
    _avg: TipoCursoAvgAggregateOutputType | null
    _sum: TipoCursoSumAggregateOutputType | null
    _min: TipoCursoMinAggregateOutputType | null
    _max: TipoCursoMaxAggregateOutputType | null
  }

  type GetTipoCursoGroupByPayload<T extends TipoCursoGroupByArgs> = Promise<
    Array<
      PickArray<TipoCursoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TipoCursoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TipoCursoGroupByOutputType[P]> 
            : GetScalarType<T[P], TipoCursoGroupByOutputType[P]>
        }
      > 
    >


  export type TipoCursoSelect = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    curso?: boolean | CursoArgs
  }

  export type TipoCursoInclude = {
    curso?: boolean | CursoArgs
  }

  export type TipoCursoGetPayload<
    S extends boolean | null | undefined | TipoCursoArgs,
    U = keyof S
      > = S extends true
        ? TipoCurso
    : S extends undefined
    ? never
    : S extends TipoCursoArgs | TipoCursoFindManyArgs
    ?'include' extends U
    ? TipoCurso  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'curso'
        ? CursoGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TipoCurso ?TipoCurso [P]
  : 
          P extends 'curso'
        ? CursoGetPayload<S['select'][P]> | null : never
  } 
    : TipoCurso
  : TipoCurso


  type TipoCursoCountArgs = Merge<
    Omit<TipoCursoFindManyArgs, 'select' | 'include'> & {
      select?: TipoCursoCountAggregateInputType | true
    }
  >

  export interface TipoCursoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TipoCurso that matches the filter.
     * @param {TipoCursoFindUniqueArgs} args - Arguments to find a TipoCurso
     * @example
     * // Get one TipoCurso
     * const tipoCurso = await prisma.tipoCurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoCursoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TipoCursoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TipoCurso'> extends True ? CheckSelect<T, Prisma__TipoCursoClient<TipoCurso>, Prisma__TipoCursoClient<TipoCursoGetPayload<T>>> : CheckSelect<T, Prisma__TipoCursoClient<TipoCurso | null >, Prisma__TipoCursoClient<TipoCursoGetPayload<T> | null >>

    /**
     * Find the first TipoCurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCursoFindFirstArgs} args - Arguments to find a TipoCurso
     * @example
     * // Get one TipoCurso
     * const tipoCurso = await prisma.tipoCurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoCursoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TipoCursoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TipoCurso'> extends True ? CheckSelect<T, Prisma__TipoCursoClient<TipoCurso>, Prisma__TipoCursoClient<TipoCursoGetPayload<T>>> : CheckSelect<T, Prisma__TipoCursoClient<TipoCurso | null >, Prisma__TipoCursoClient<TipoCursoGetPayload<T> | null >>

    /**
     * Find zero or more TipoCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCursoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoCursos
     * const tipoCursos = await prisma.tipoCurso.findMany()
     * 
     * // Get first 10 TipoCursos
     * const tipoCursos = await prisma.tipoCurso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoCursoWithIdOnly = await prisma.tipoCurso.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TipoCursoFindManyArgs>(
      args?: SelectSubset<T, TipoCursoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TipoCurso>>, PrismaPromise<Array<TipoCursoGetPayload<T>>>>

    /**
     * Create a TipoCurso.
     * @param {TipoCursoCreateArgs} args - Arguments to create a TipoCurso.
     * @example
     * // Create one TipoCurso
     * const TipoCurso = await prisma.tipoCurso.create({
     *   data: {
     *     // ... data to create a TipoCurso
     *   }
     * })
     * 
    **/
    create<T extends TipoCursoCreateArgs>(
      args: SelectSubset<T, TipoCursoCreateArgs>
    ): CheckSelect<T, Prisma__TipoCursoClient<TipoCurso>, Prisma__TipoCursoClient<TipoCursoGetPayload<T>>>

    /**
     * Create many TipoCursos.
     *     @param {TipoCursoCreateManyArgs} args - Arguments to create many TipoCursos.
     *     @example
     *     // Create many TipoCursos
     *     const tipoCurso = await prisma.tipoCurso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoCursoCreateManyArgs>(
      args?: SelectSubset<T, TipoCursoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TipoCurso.
     * @param {TipoCursoDeleteArgs} args - Arguments to delete one TipoCurso.
     * @example
     * // Delete one TipoCurso
     * const TipoCurso = await prisma.tipoCurso.delete({
     *   where: {
     *     // ... filter to delete one TipoCurso
     *   }
     * })
     * 
    **/
    delete<T extends TipoCursoDeleteArgs>(
      args: SelectSubset<T, TipoCursoDeleteArgs>
    ): CheckSelect<T, Prisma__TipoCursoClient<TipoCurso>, Prisma__TipoCursoClient<TipoCursoGetPayload<T>>>

    /**
     * Update one TipoCurso.
     * @param {TipoCursoUpdateArgs} args - Arguments to update one TipoCurso.
     * @example
     * // Update one TipoCurso
     * const tipoCurso = await prisma.tipoCurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoCursoUpdateArgs>(
      args: SelectSubset<T, TipoCursoUpdateArgs>
    ): CheckSelect<T, Prisma__TipoCursoClient<TipoCurso>, Prisma__TipoCursoClient<TipoCursoGetPayload<T>>>

    /**
     * Delete zero or more TipoCursos.
     * @param {TipoCursoDeleteManyArgs} args - Arguments to filter TipoCursos to delete.
     * @example
     * // Delete a few TipoCursos
     * const { count } = await prisma.tipoCurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoCursoDeleteManyArgs>(
      args?: SelectSubset<T, TipoCursoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoCursos
     * const tipoCurso = await prisma.tipoCurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoCursoUpdateManyArgs>(
      args: SelectSubset<T, TipoCursoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoCurso.
     * @param {TipoCursoUpsertArgs} args - Arguments to update or create a TipoCurso.
     * @example
     * // Update or create a TipoCurso
     * const tipoCurso = await prisma.tipoCurso.upsert({
     *   create: {
     *     // ... data to create a TipoCurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoCurso we want to update
     *   }
     * })
    **/
    upsert<T extends TipoCursoUpsertArgs>(
      args: SelectSubset<T, TipoCursoUpsertArgs>
    ): CheckSelect<T, Prisma__TipoCursoClient<TipoCurso>, Prisma__TipoCursoClient<TipoCursoGetPayload<T>>>

    /**
     * Count the number of TipoCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCursoCountArgs} args - Arguments to filter TipoCursos to count.
     * @example
     * // Count the number of TipoCursos
     * const count = await prisma.tipoCurso.count({
     *   where: {
     *     // ... the filter for the TipoCursos we want to count
     *   }
     * })
    **/
    count<T extends TipoCursoCountArgs>(
      args?: Subset<T, TipoCursoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoCursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoCursoAggregateArgs>(args: Subset<T, TipoCursoAggregateArgs>): PrismaPromise<GetTipoCursoAggregateType<T>>

    /**
     * Group by TipoCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoCursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoCursoGroupByArgs['orderBy'] }
        : { orderBy?: TipoCursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoCursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoCursoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoCurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TipoCursoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    curso<T extends CursoArgs = {}>(args?: Subset<T, CursoArgs>): CheckSelect<T, Prisma__CursoClient<Curso | null >, Prisma__CursoClient<CursoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TipoCurso findUnique
   */
  export type TipoCursoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
    /**
     * Throw an Error if a TipoCurso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TipoCurso to fetch.
     * 
    **/
    where: TipoCursoWhereUniqueInput
  }


  /**
   * TipoCurso findFirst
   */
  export type TipoCursoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
    /**
     * Throw an Error if a TipoCurso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TipoCurso to fetch.
     * 
    **/
    where?: TipoCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoCursos.
     * 
    **/
    cursor?: TipoCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoCursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoCursos.
     * 
    **/
    distinct?: Enumerable<TipoCursoScalarFieldEnum>
  }


  /**
   * TipoCurso findMany
   */
  export type TipoCursoFindManyArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
    /**
     * Filter, which TipoCursos to fetch.
     * 
    **/
    where?: TipoCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<TipoCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoCursos.
     * 
    **/
    cursor?: TipoCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoCursos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TipoCursoScalarFieldEnum>
  }


  /**
   * TipoCurso create
   */
  export type TipoCursoCreateArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
    /**
     * The data needed to create a TipoCurso.
     * 
    **/
    data: XOR<TipoCursoCreateInput, TipoCursoUncheckedCreateInput>
  }


  /**
   * TipoCurso createMany
   */
  export type TipoCursoCreateManyArgs = {
    data: Enumerable<TipoCursoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TipoCurso update
   */
  export type TipoCursoUpdateArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
    /**
     * The data needed to update a TipoCurso.
     * 
    **/
    data: XOR<TipoCursoUpdateInput, TipoCursoUncheckedUpdateInput>
    /**
     * Choose, which TipoCurso to update.
     * 
    **/
    where: TipoCursoWhereUniqueInput
  }


  /**
   * TipoCurso updateMany
   */
  export type TipoCursoUpdateManyArgs = {
    data: XOR<TipoCursoUpdateManyMutationInput, TipoCursoUncheckedUpdateManyInput>
    where?: TipoCursoWhereInput
  }


  /**
   * TipoCurso upsert
   */
  export type TipoCursoUpsertArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
    /**
     * The filter to search for the TipoCurso to update in case it exists.
     * 
    **/
    where: TipoCursoWhereUniqueInput
    /**
     * In case the TipoCurso found by the `where` argument doesn't exist, create a new TipoCurso with this data.
     * 
    **/
    create: XOR<TipoCursoCreateInput, TipoCursoUncheckedCreateInput>
    /**
     * In case the TipoCurso was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TipoCursoUpdateInput, TipoCursoUncheckedUpdateInput>
  }


  /**
   * TipoCurso delete
   */
  export type TipoCursoDeleteArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
    /**
     * Filter which TipoCurso to delete.
     * 
    **/
    where: TipoCursoWhereUniqueInput
  }


  /**
   * TipoCurso deleteMany
   */
  export type TipoCursoDeleteManyArgs = {
    where?: TipoCursoWhereInput
  }


  /**
   * TipoCurso without action
   */
  export type TipoCursoArgs = {
    /**
     * Select specific fields to fetch from the TipoCurso
     * 
    **/
    select?: TipoCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TipoCursoInclude | null
  }



  /**
   * Model Curso
   */


  export type AggregateCurso = {
    _count: CursoCountAggregateOutputType | null
    count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
    max: CursoMaxAggregateOutputType | null
  }

  export type CursoAvgAggregateOutputType = {
    id: number | null
    tipoCursoId: number | null
  }

  export type CursoSumAggregateOutputType = {
    id: number | null
    tipoCursoId: number | null
  }

  export type CursoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    tipoCursoId: number | null
  }

  export type CursoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    tipoCursoId: number | null
  }

  export type CursoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    tipoCursoId: number
    _all: number
  }


  export type CursoAvgAggregateInputType = {
    id?: true
    tipoCursoId?: true
  }

  export type CursoSumAggregateInputType = {
    id?: true
    tipoCursoId?: true
  }

  export type CursoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    tipoCursoId?: true
  }

  export type CursoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    tipoCursoId?: true
  }

  export type CursoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    tipoCursoId?: true
    _all?: true
  }

  export type CursoAggregateArgs = {
    /**
     * Filter which Curso to aggregate.
     * 
    **/
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     * 
    **/
    orderBy?: Enumerable<CursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cursos
    **/
    _count?: true | CursoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CursoMaxAggregateInputType
  }

  export type GetCursoAggregateType<T extends CursoAggregateArgs> = {
        [P in keyof T & keyof AggregateCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurso[P]>
      : GetScalarType<T[P], AggregateCurso[P]>
  }


    
    
  export type CursoGroupByArgs = {
    where?: CursoWhereInput
    orderBy?: Enumerable<CursoOrderByInput>
    by: Array<CursoScalarFieldEnum>
    having?: CursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursoCountAggregateInputType | true
    _avg?: CursoAvgAggregateInputType
    _sum?: CursoSumAggregateInputType
    _min?: CursoMinAggregateInputType
    _max?: CursoMaxAggregateInputType
  }


  export type CursoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    tipoCursoId: number
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  type GetCursoGroupByPayload<T extends CursoGroupByArgs> = Promise<
    Array<
      PickArray<CursoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CursoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CursoGroupByOutputType[P]> 
            : GetScalarType<T[P], CursoGroupByOutputType[P]>
        }
      > 
    >


  export type CursoSelect = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    destinatatios?: boolean | DestinatarioOnCursoFindManyArgs
    localidad?: boolean | LocalidadOnCursoFindManyArgs
    tipocurso?: boolean | TipoCursoArgs
    tipoCursoId?: boolean
  }

  export type CursoInclude = {
    destinatatios?: boolean | DestinatarioOnCursoFindManyArgs
    localidad?: boolean | LocalidadOnCursoFindManyArgs
    tipocurso?: boolean | TipoCursoArgs
  }

  export type CursoGetPayload<
    S extends boolean | null | undefined | CursoArgs,
    U = keyof S
      > = S extends true
        ? Curso
    : S extends undefined
    ? never
    : S extends CursoArgs | CursoFindManyArgs
    ?'include' extends U
    ? Curso  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'destinatatios'
        ? Array < DestinatarioOnCursoGetPayload<S['include'][P]>>  :
        P extends 'localidad'
        ? Array < LocalidadOnCursoGetPayload<S['include'][P]>>  :
        P extends 'tipocurso'
        ? TipoCursoGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Curso ?Curso [P]
  : 
          P extends 'destinatatios'
        ? Array < DestinatarioOnCursoGetPayload<S['select'][P]>>  :
        P extends 'localidad'
        ? Array < LocalidadOnCursoGetPayload<S['select'][P]>>  :
        P extends 'tipocurso'
        ? TipoCursoGetPayload<S['select'][P]> | null : never
  } 
    : Curso
  : Curso


  type CursoCountArgs = Merge<
    Omit<CursoFindManyArgs, 'select' | 'include'> & {
      select?: CursoCountAggregateInputType | true
    }
  >

  export interface CursoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Curso that matches the filter.
     * @param {CursoFindUniqueArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CursoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CursoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Curso'> extends True ? CheckSelect<T, Prisma__CursoClient<Curso>, Prisma__CursoClient<CursoGetPayload<T>>> : CheckSelect<T, Prisma__CursoClient<Curso | null >, Prisma__CursoClient<CursoGetPayload<T> | null >>

    /**
     * Find the first Curso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CursoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CursoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Curso'> extends True ? CheckSelect<T, Prisma__CursoClient<Curso>, Prisma__CursoClient<CursoGetPayload<T>>> : CheckSelect<T, Prisma__CursoClient<Curso | null >, Prisma__CursoClient<CursoGetPayload<T> | null >>

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.curso.findMany()
     * 
     * // Get first 10 Cursos
     * const cursos = await prisma.curso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursoWithIdOnly = await prisma.curso.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CursoFindManyArgs>(
      args?: SelectSubset<T, CursoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Curso>>, PrismaPromise<Array<CursoGetPayload<T>>>>

    /**
     * Create a Curso.
     * @param {CursoCreateArgs} args - Arguments to create a Curso.
     * @example
     * // Create one Curso
     * const Curso = await prisma.curso.create({
     *   data: {
     *     // ... data to create a Curso
     *   }
     * })
     * 
    **/
    create<T extends CursoCreateArgs>(
      args: SelectSubset<T, CursoCreateArgs>
    ): CheckSelect<T, Prisma__CursoClient<Curso>, Prisma__CursoClient<CursoGetPayload<T>>>

    /**
     * Create many Cursos.
     *     @param {CursoCreateManyArgs} args - Arguments to create many Cursos.
     *     @example
     *     // Create many Cursos
     *     const curso = await prisma.curso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CursoCreateManyArgs>(
      args?: SelectSubset<T, CursoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Curso.
     * @param {CursoDeleteArgs} args - Arguments to delete one Curso.
     * @example
     * // Delete one Curso
     * const Curso = await prisma.curso.delete({
     *   where: {
     *     // ... filter to delete one Curso
     *   }
     * })
     * 
    **/
    delete<T extends CursoDeleteArgs>(
      args: SelectSubset<T, CursoDeleteArgs>
    ): CheckSelect<T, Prisma__CursoClient<Curso>, Prisma__CursoClient<CursoGetPayload<T>>>

    /**
     * Update one Curso.
     * @param {CursoUpdateArgs} args - Arguments to update one Curso.
     * @example
     * // Update one Curso
     * const curso = await prisma.curso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CursoUpdateArgs>(
      args: SelectSubset<T, CursoUpdateArgs>
    ): CheckSelect<T, Prisma__CursoClient<Curso>, Prisma__CursoClient<CursoGetPayload<T>>>

    /**
     * Delete zero or more Cursos.
     * @param {CursoDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.curso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CursoDeleteManyArgs>(
      args?: SelectSubset<T, CursoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const curso = await prisma.curso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CursoUpdateManyArgs>(
      args: SelectSubset<T, CursoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Curso.
     * @param {CursoUpsertArgs} args - Arguments to update or create a Curso.
     * @example
     * // Update or create a Curso
     * const curso = await prisma.curso.upsert({
     *   create: {
     *     // ... data to create a Curso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curso we want to update
     *   }
     * })
    **/
    upsert<T extends CursoUpsertArgs>(
      args: SelectSubset<T, CursoUpsertArgs>
    ): CheckSelect<T, Prisma__CursoClient<Curso>, Prisma__CursoClient<CursoGetPayload<T>>>

    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.curso.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
    **/
    count<T extends CursoCountArgs>(
      args?: Subset<T, CursoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursoAggregateArgs>(args: Subset<T, CursoAggregateArgs>): PrismaPromise<GetCursoAggregateType<T>>

    /**
     * Group by Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoGroupByArgs['orderBy'] }
        : { orderBy?: CursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CursoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    destinatatios<T extends DestinatarioOnCursoFindManyArgs = {}>(args?: Subset<T, DestinatarioOnCursoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DestinatarioOnCurso>>, PrismaPromise<Array<DestinatarioOnCursoGetPayload<T>>>>;

    localidad<T extends LocalidadOnCursoFindManyArgs = {}>(args?: Subset<T, LocalidadOnCursoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LocalidadOnCurso>>, PrismaPromise<Array<LocalidadOnCursoGetPayload<T>>>>;

    tipocurso<T extends TipoCursoArgs = {}>(args?: Subset<T, TipoCursoArgs>): CheckSelect<T, Prisma__TipoCursoClient<TipoCurso | null >, Prisma__TipoCursoClient<TipoCursoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Curso findUnique
   */
  export type CursoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
    /**
     * Throw an Error if a Curso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Curso to fetch.
     * 
    **/
    where: CursoWhereUniqueInput
  }


  /**
   * Curso findFirst
   */
  export type CursoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
    /**
     * Throw an Error if a Curso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Curso to fetch.
     * 
    **/
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     * 
    **/
    orderBy?: Enumerable<CursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     * 
    **/
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     * 
    **/
    distinct?: Enumerable<CursoScalarFieldEnum>
  }


  /**
   * Curso findMany
   */
  export type CursoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
    /**
     * Filter, which Cursos to fetch.
     * 
    **/
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     * 
    **/
    orderBy?: Enumerable<CursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cursos.
     * 
    **/
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CursoScalarFieldEnum>
  }


  /**
   * Curso create
   */
  export type CursoCreateArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
    /**
     * The data needed to create a Curso.
     * 
    **/
    data: XOR<CursoCreateInput, CursoUncheckedCreateInput>
  }


  /**
   * Curso createMany
   */
  export type CursoCreateManyArgs = {
    data: Enumerable<CursoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Curso update
   */
  export type CursoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
    /**
     * The data needed to update a Curso.
     * 
    **/
    data: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
    /**
     * Choose, which Curso to update.
     * 
    **/
    where: CursoWhereUniqueInput
  }


  /**
   * Curso updateMany
   */
  export type CursoUpdateManyArgs = {
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyInput>
    where?: CursoWhereInput
  }


  /**
   * Curso upsert
   */
  export type CursoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
    /**
     * The filter to search for the Curso to update in case it exists.
     * 
    **/
    where: CursoWhereUniqueInput
    /**
     * In case the Curso found by the `where` argument doesn't exist, create a new Curso with this data.
     * 
    **/
    create: XOR<CursoCreateInput, CursoUncheckedCreateInput>
    /**
     * In case the Curso was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
  }


  /**
   * Curso delete
   */
  export type CursoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
    /**
     * Filter which Curso to delete.
     * 
    **/
    where: CursoWhereUniqueInput
  }


  /**
   * Curso deleteMany
   */
  export type CursoDeleteManyArgs = {
    where?: CursoWhereInput
  }


  /**
   * Curso without action
   */
  export type CursoArgs = {
    /**
     * Select specific fields to fetch from the Curso
     * 
    **/
    select?: CursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursoInclude | null
  }



  /**
   * Model LocalidadOnCurso
   */


  export type AggregateLocalidadOnCurso = {
    _count: LocalidadOnCursoCountAggregateOutputType | null
    count: LocalidadOnCursoCountAggregateOutputType | null
    _avg: LocalidadOnCursoAvgAggregateOutputType | null
    avg: LocalidadOnCursoAvgAggregateOutputType | null
    _sum: LocalidadOnCursoSumAggregateOutputType | null
    sum: LocalidadOnCursoSumAggregateOutputType | null
    _min: LocalidadOnCursoMinAggregateOutputType | null
    min: LocalidadOnCursoMinAggregateOutputType | null
    _max: LocalidadOnCursoMaxAggregateOutputType | null
    max: LocalidadOnCursoMaxAggregateOutputType | null
  }

  export type LocalidadOnCursoAvgAggregateOutputType = {
    cursoId: number | null
    localidadId: number | null
  }

  export type LocalidadOnCursoSumAggregateOutputType = {
    cursoId: number | null
    localidadId: number | null
  }

  export type LocalidadOnCursoMinAggregateOutputType = {
    cursoId: number | null
    localidadId: number | null
    nombreMostrar: string | null
    descripcion: string | null
  }

  export type LocalidadOnCursoMaxAggregateOutputType = {
    cursoId: number | null
    localidadId: number | null
    nombreMostrar: string | null
    descripcion: string | null
  }

  export type LocalidadOnCursoCountAggregateOutputType = {
    cursoId: number
    localidadId: number
    nombreMostrar: number
    descripcion: number
    _all: number
  }


  export type LocalidadOnCursoAvgAggregateInputType = {
    cursoId?: true
    localidadId?: true
  }

  export type LocalidadOnCursoSumAggregateInputType = {
    cursoId?: true
    localidadId?: true
  }

  export type LocalidadOnCursoMinAggregateInputType = {
    cursoId?: true
    localidadId?: true
    nombreMostrar?: true
    descripcion?: true
  }

  export type LocalidadOnCursoMaxAggregateInputType = {
    cursoId?: true
    localidadId?: true
    nombreMostrar?: true
    descripcion?: true
  }

  export type LocalidadOnCursoCountAggregateInputType = {
    cursoId?: true
    localidadId?: true
    nombreMostrar?: true
    descripcion?: true
    _all?: true
  }

  export type LocalidadOnCursoAggregateArgs = {
    /**
     * Filter which LocalidadOnCurso to aggregate.
     * 
    **/
    where?: LocalidadOnCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalidadOnCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalidadOnCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LocalidadOnCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalidadOnCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalidadOnCursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalidadOnCursos
    **/
    _count?: true | LocalidadOnCursoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | LocalidadOnCursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalidadOnCursoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: LocalidadOnCursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalidadOnCursoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: LocalidadOnCursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalidadOnCursoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: LocalidadOnCursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalidadOnCursoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: LocalidadOnCursoMaxAggregateInputType
  }

  export type GetLocalidadOnCursoAggregateType<T extends LocalidadOnCursoAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalidadOnCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalidadOnCurso[P]>
      : GetScalarType<T[P], AggregateLocalidadOnCurso[P]>
  }


    
    
  export type LocalidadOnCursoGroupByArgs = {
    where?: LocalidadOnCursoWhereInput
    orderBy?: Enumerable<LocalidadOnCursoOrderByInput>
    by: Array<LocalidadOnCursoScalarFieldEnum>
    having?: LocalidadOnCursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalidadOnCursoCountAggregateInputType | true
    _avg?: LocalidadOnCursoAvgAggregateInputType
    _sum?: LocalidadOnCursoSumAggregateInputType
    _min?: LocalidadOnCursoMinAggregateInputType
    _max?: LocalidadOnCursoMaxAggregateInputType
  }


  export type LocalidadOnCursoGroupByOutputType = {
    cursoId: number
    localidadId: number
    nombreMostrar: string
    descripcion: string
    _count: LocalidadOnCursoCountAggregateOutputType | null
    _avg: LocalidadOnCursoAvgAggregateOutputType | null
    _sum: LocalidadOnCursoSumAggregateOutputType | null
    _min: LocalidadOnCursoMinAggregateOutputType | null
    _max: LocalidadOnCursoMaxAggregateOutputType | null
  }

  type GetLocalidadOnCursoGroupByPayload<T extends LocalidadOnCursoGroupByArgs> = Promise<
    Array<
      PickArray<LocalidadOnCursoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof LocalidadOnCursoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], LocalidadOnCursoGroupByOutputType[P]> 
            : GetScalarType<T[P], LocalidadOnCursoGroupByOutputType[P]>
        }
      > 
    >


  export type LocalidadOnCursoSelect = {
    curso?: boolean | CursoArgs
    cursoId?: boolean
    localidad?: boolean | LocalidadArgs
    localidadId?: boolean
    nombreMostrar?: boolean
    descripcion?: boolean
    cursosActivos?: boolean | CursosActivosFindManyArgs
  }

  export type LocalidadOnCursoInclude = {
    curso?: boolean | CursoArgs
    localidad?: boolean | LocalidadArgs
    cursosActivos?: boolean | CursosActivosFindManyArgs
  }

  export type LocalidadOnCursoGetPayload<
    S extends boolean | null | undefined | LocalidadOnCursoArgs,
    U = keyof S
      > = S extends true
        ? LocalidadOnCurso
    : S extends undefined
    ? never
    : S extends LocalidadOnCursoArgs | LocalidadOnCursoFindManyArgs
    ?'include' extends U
    ? LocalidadOnCurso  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'curso'
        ? CursoGetPayload<S['include'][P]> :
        P extends 'localidad'
        ? LocalidadGetPayload<S['include'][P]> :
        P extends 'cursosActivos'
        ? Array < CursosActivosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LocalidadOnCurso ?LocalidadOnCurso [P]
  : 
          P extends 'curso'
        ? CursoGetPayload<S['select'][P]> :
        P extends 'localidad'
        ? LocalidadGetPayload<S['select'][P]> :
        P extends 'cursosActivos'
        ? Array < CursosActivosGetPayload<S['select'][P]>>  : never
  } 
    : LocalidadOnCurso
  : LocalidadOnCurso


  type LocalidadOnCursoCountArgs = Merge<
    Omit<LocalidadOnCursoFindManyArgs, 'select' | 'include'> & {
      select?: LocalidadOnCursoCountAggregateInputType | true
    }
  >

  export interface LocalidadOnCursoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LocalidadOnCurso that matches the filter.
     * @param {LocalidadOnCursoFindUniqueArgs} args - Arguments to find a LocalidadOnCurso
     * @example
     * // Get one LocalidadOnCurso
     * const localidadOnCurso = await prisma.localidadOnCurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocalidadOnCursoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LocalidadOnCursoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LocalidadOnCurso'> extends True ? CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso>, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T>>> : CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso | null >, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T> | null >>

    /**
     * Find the first LocalidadOnCurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadOnCursoFindFirstArgs} args - Arguments to find a LocalidadOnCurso
     * @example
     * // Get one LocalidadOnCurso
     * const localidadOnCurso = await prisma.localidadOnCurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocalidadOnCursoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LocalidadOnCursoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LocalidadOnCurso'> extends True ? CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso>, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T>>> : CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso | null >, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T> | null >>

    /**
     * Find zero or more LocalidadOnCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadOnCursoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalidadOnCursos
     * const localidadOnCursos = await prisma.localidadOnCurso.findMany()
     * 
     * // Get first 10 LocalidadOnCursos
     * const localidadOnCursos = await prisma.localidadOnCurso.findMany({ take: 10 })
     * 
     * // Only select the `cursoId`
     * const localidadOnCursoWithCursoIdOnly = await prisma.localidadOnCurso.findMany({ select: { cursoId: true } })
     * 
    **/
    findMany<T extends LocalidadOnCursoFindManyArgs>(
      args?: SelectSubset<T, LocalidadOnCursoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LocalidadOnCurso>>, PrismaPromise<Array<LocalidadOnCursoGetPayload<T>>>>

    /**
     * Create a LocalidadOnCurso.
     * @param {LocalidadOnCursoCreateArgs} args - Arguments to create a LocalidadOnCurso.
     * @example
     * // Create one LocalidadOnCurso
     * const LocalidadOnCurso = await prisma.localidadOnCurso.create({
     *   data: {
     *     // ... data to create a LocalidadOnCurso
     *   }
     * })
     * 
    **/
    create<T extends LocalidadOnCursoCreateArgs>(
      args: SelectSubset<T, LocalidadOnCursoCreateArgs>
    ): CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso>, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T>>>

    /**
     * Create many LocalidadOnCursos.
     *     @param {LocalidadOnCursoCreateManyArgs} args - Arguments to create many LocalidadOnCursos.
     *     @example
     *     // Create many LocalidadOnCursos
     *     const localidadOnCurso = await prisma.localidadOnCurso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocalidadOnCursoCreateManyArgs>(
      args?: SelectSubset<T, LocalidadOnCursoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LocalidadOnCurso.
     * @param {LocalidadOnCursoDeleteArgs} args - Arguments to delete one LocalidadOnCurso.
     * @example
     * // Delete one LocalidadOnCurso
     * const LocalidadOnCurso = await prisma.localidadOnCurso.delete({
     *   where: {
     *     // ... filter to delete one LocalidadOnCurso
     *   }
     * })
     * 
    **/
    delete<T extends LocalidadOnCursoDeleteArgs>(
      args: SelectSubset<T, LocalidadOnCursoDeleteArgs>
    ): CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso>, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T>>>

    /**
     * Update one LocalidadOnCurso.
     * @param {LocalidadOnCursoUpdateArgs} args - Arguments to update one LocalidadOnCurso.
     * @example
     * // Update one LocalidadOnCurso
     * const localidadOnCurso = await prisma.localidadOnCurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocalidadOnCursoUpdateArgs>(
      args: SelectSubset<T, LocalidadOnCursoUpdateArgs>
    ): CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso>, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T>>>

    /**
     * Delete zero or more LocalidadOnCursos.
     * @param {LocalidadOnCursoDeleteManyArgs} args - Arguments to filter LocalidadOnCursos to delete.
     * @example
     * // Delete a few LocalidadOnCursos
     * const { count } = await prisma.localidadOnCurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocalidadOnCursoDeleteManyArgs>(
      args?: SelectSubset<T, LocalidadOnCursoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalidadOnCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadOnCursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalidadOnCursos
     * const localidadOnCurso = await prisma.localidadOnCurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocalidadOnCursoUpdateManyArgs>(
      args: SelectSubset<T, LocalidadOnCursoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalidadOnCurso.
     * @param {LocalidadOnCursoUpsertArgs} args - Arguments to update or create a LocalidadOnCurso.
     * @example
     * // Update or create a LocalidadOnCurso
     * const localidadOnCurso = await prisma.localidadOnCurso.upsert({
     *   create: {
     *     // ... data to create a LocalidadOnCurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalidadOnCurso we want to update
     *   }
     * })
    **/
    upsert<T extends LocalidadOnCursoUpsertArgs>(
      args: SelectSubset<T, LocalidadOnCursoUpsertArgs>
    ): CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso>, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T>>>

    /**
     * Count the number of LocalidadOnCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadOnCursoCountArgs} args - Arguments to filter LocalidadOnCursos to count.
     * @example
     * // Count the number of LocalidadOnCursos
     * const count = await prisma.localidadOnCurso.count({
     *   where: {
     *     // ... the filter for the LocalidadOnCursos we want to count
     *   }
     * })
    **/
    count<T extends LocalidadOnCursoCountArgs>(
      args?: Subset<T, LocalidadOnCursoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalidadOnCursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalidadOnCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadOnCursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalidadOnCursoAggregateArgs>(args: Subset<T, LocalidadOnCursoAggregateArgs>): PrismaPromise<GetLocalidadOnCursoAggregateType<T>>

    /**
     * Group by LocalidadOnCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadOnCursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalidadOnCursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalidadOnCursoGroupByArgs['orderBy'] }
        : { orderBy?: LocalidadOnCursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalidadOnCursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalidadOnCursoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalidadOnCurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LocalidadOnCursoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    curso<T extends CursoArgs = {}>(args?: Subset<T, CursoArgs>): CheckSelect<T, Prisma__CursoClient<Curso | null >, Prisma__CursoClient<CursoGetPayload<T> | null >>;

    localidad<T extends LocalidadArgs = {}>(args?: Subset<T, LocalidadArgs>): CheckSelect<T, Prisma__LocalidadClient<Localidad | null >, Prisma__LocalidadClient<LocalidadGetPayload<T> | null >>;

    cursosActivos<T extends CursosActivosFindManyArgs = {}>(args?: Subset<T, CursosActivosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CursosActivos>>, PrismaPromise<Array<CursosActivosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LocalidadOnCurso findUnique
   */
  export type LocalidadOnCursoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
    /**
     * Throw an Error if a LocalidadOnCurso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LocalidadOnCurso to fetch.
     * 
    **/
    where: LocalidadOnCursoWhereUniqueInput
  }


  /**
   * LocalidadOnCurso findFirst
   */
  export type LocalidadOnCursoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
    /**
     * Throw an Error if a LocalidadOnCurso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LocalidadOnCurso to fetch.
     * 
    **/
    where?: LocalidadOnCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalidadOnCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalidadOnCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalidadOnCursos.
     * 
    **/
    cursor?: LocalidadOnCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalidadOnCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalidadOnCursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalidadOnCursos.
     * 
    **/
    distinct?: Enumerable<LocalidadOnCursoScalarFieldEnum>
  }


  /**
   * LocalidadOnCurso findMany
   */
  export type LocalidadOnCursoFindManyArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
    /**
     * Filter, which LocalidadOnCursos to fetch.
     * 
    **/
    where?: LocalidadOnCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalidadOnCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<LocalidadOnCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalidadOnCursos.
     * 
    **/
    cursor?: LocalidadOnCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalidadOnCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalidadOnCursos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocalidadOnCursoScalarFieldEnum>
  }


  /**
   * LocalidadOnCurso create
   */
  export type LocalidadOnCursoCreateArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
    /**
     * The data needed to create a LocalidadOnCurso.
     * 
    **/
    data: XOR<LocalidadOnCursoCreateInput, LocalidadOnCursoUncheckedCreateInput>
  }


  /**
   * LocalidadOnCurso createMany
   */
  export type LocalidadOnCursoCreateManyArgs = {
    data: Enumerable<LocalidadOnCursoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LocalidadOnCurso update
   */
  export type LocalidadOnCursoUpdateArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
    /**
     * The data needed to update a LocalidadOnCurso.
     * 
    **/
    data: XOR<LocalidadOnCursoUpdateInput, LocalidadOnCursoUncheckedUpdateInput>
    /**
     * Choose, which LocalidadOnCurso to update.
     * 
    **/
    where: LocalidadOnCursoWhereUniqueInput
  }


  /**
   * LocalidadOnCurso updateMany
   */
  export type LocalidadOnCursoUpdateManyArgs = {
    data: XOR<LocalidadOnCursoUpdateManyMutationInput, LocalidadOnCursoUncheckedUpdateManyInput>
    where?: LocalidadOnCursoWhereInput
  }


  /**
   * LocalidadOnCurso upsert
   */
  export type LocalidadOnCursoUpsertArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
    /**
     * The filter to search for the LocalidadOnCurso to update in case it exists.
     * 
    **/
    where: LocalidadOnCursoWhereUniqueInput
    /**
     * In case the LocalidadOnCurso found by the `where` argument doesn't exist, create a new LocalidadOnCurso with this data.
     * 
    **/
    create: XOR<LocalidadOnCursoCreateInput, LocalidadOnCursoUncheckedCreateInput>
    /**
     * In case the LocalidadOnCurso was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LocalidadOnCursoUpdateInput, LocalidadOnCursoUncheckedUpdateInput>
  }


  /**
   * LocalidadOnCurso delete
   */
  export type LocalidadOnCursoDeleteArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
    /**
     * Filter which LocalidadOnCurso to delete.
     * 
    **/
    where: LocalidadOnCursoWhereUniqueInput
  }


  /**
   * LocalidadOnCurso deleteMany
   */
  export type LocalidadOnCursoDeleteManyArgs = {
    where?: LocalidadOnCursoWhereInput
  }


  /**
   * LocalidadOnCurso without action
   */
  export type LocalidadOnCursoArgs = {
    /**
     * Select specific fields to fetch from the LocalidadOnCurso
     * 
    **/
    select?: LocalidadOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocalidadOnCursoInclude | null
  }



  /**
   * Model DestinatarioOnCurso
   */


  export type AggregateDestinatarioOnCurso = {
    _count: DestinatarioOnCursoCountAggregateOutputType | null
    count: DestinatarioOnCursoCountAggregateOutputType | null
    _avg: DestinatarioOnCursoAvgAggregateOutputType | null
    avg: DestinatarioOnCursoAvgAggregateOutputType | null
    _sum: DestinatarioOnCursoSumAggregateOutputType | null
    sum: DestinatarioOnCursoSumAggregateOutputType | null
    _min: DestinatarioOnCursoMinAggregateOutputType | null
    min: DestinatarioOnCursoMinAggregateOutputType | null
    _max: DestinatarioOnCursoMaxAggregateOutputType | null
    max: DestinatarioOnCursoMaxAggregateOutputType | null
  }

  export type DestinatarioOnCursoAvgAggregateOutputType = {
    cursoId: number | null
    destinatarioId: number | null
  }

  export type DestinatarioOnCursoSumAggregateOutputType = {
    cursoId: number | null
    destinatarioId: number | null
  }

  export type DestinatarioOnCursoMinAggregateOutputType = {
    cursoId: number | null
    destinatarioId: number | null
    descripcion: string | null
    nombreMostrar: string | null
  }

  export type DestinatarioOnCursoMaxAggregateOutputType = {
    cursoId: number | null
    destinatarioId: number | null
    descripcion: string | null
    nombreMostrar: string | null
  }

  export type DestinatarioOnCursoCountAggregateOutputType = {
    cursoId: number
    destinatarioId: number
    descripcion: number
    nombreMostrar: number
    _all: number
  }


  export type DestinatarioOnCursoAvgAggregateInputType = {
    cursoId?: true
    destinatarioId?: true
  }

  export type DestinatarioOnCursoSumAggregateInputType = {
    cursoId?: true
    destinatarioId?: true
  }

  export type DestinatarioOnCursoMinAggregateInputType = {
    cursoId?: true
    destinatarioId?: true
    descripcion?: true
    nombreMostrar?: true
  }

  export type DestinatarioOnCursoMaxAggregateInputType = {
    cursoId?: true
    destinatarioId?: true
    descripcion?: true
    nombreMostrar?: true
  }

  export type DestinatarioOnCursoCountAggregateInputType = {
    cursoId?: true
    destinatarioId?: true
    descripcion?: true
    nombreMostrar?: true
    _all?: true
  }

  export type DestinatarioOnCursoAggregateArgs = {
    /**
     * Filter which DestinatarioOnCurso to aggregate.
     * 
    **/
    where?: DestinatarioOnCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinatarioOnCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<DestinatarioOnCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DestinatarioOnCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinatarioOnCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinatarioOnCursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DestinatarioOnCursos
    **/
    _count?: true | DestinatarioOnCursoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | DestinatarioOnCursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinatarioOnCursoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: DestinatarioOnCursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinatarioOnCursoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: DestinatarioOnCursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinatarioOnCursoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: DestinatarioOnCursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinatarioOnCursoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: DestinatarioOnCursoMaxAggregateInputType
  }

  export type GetDestinatarioOnCursoAggregateType<T extends DestinatarioOnCursoAggregateArgs> = {
        [P in keyof T & keyof AggregateDestinatarioOnCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestinatarioOnCurso[P]>
      : GetScalarType<T[P], AggregateDestinatarioOnCurso[P]>
  }


    
    
  export type DestinatarioOnCursoGroupByArgs = {
    where?: DestinatarioOnCursoWhereInput
    orderBy?: Enumerable<DestinatarioOnCursoOrderByInput>
    by: Array<DestinatarioOnCursoScalarFieldEnum>
    having?: DestinatarioOnCursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinatarioOnCursoCountAggregateInputType | true
    _avg?: DestinatarioOnCursoAvgAggregateInputType
    _sum?: DestinatarioOnCursoSumAggregateInputType
    _min?: DestinatarioOnCursoMinAggregateInputType
    _max?: DestinatarioOnCursoMaxAggregateInputType
  }


  export type DestinatarioOnCursoGroupByOutputType = {
    cursoId: number
    destinatarioId: number
    descripcion: string
    nombreMostrar: string
    _count: DestinatarioOnCursoCountAggregateOutputType | null
    _avg: DestinatarioOnCursoAvgAggregateOutputType | null
    _sum: DestinatarioOnCursoSumAggregateOutputType | null
    _min: DestinatarioOnCursoMinAggregateOutputType | null
    _max: DestinatarioOnCursoMaxAggregateOutputType | null
  }

  type GetDestinatarioOnCursoGroupByPayload<T extends DestinatarioOnCursoGroupByArgs> = Promise<
    Array<
      PickArray<DestinatarioOnCursoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof DestinatarioOnCursoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], DestinatarioOnCursoGroupByOutputType[P]> 
            : GetScalarType<T[P], DestinatarioOnCursoGroupByOutputType[P]>
        }
      > 
    >


  export type DestinatarioOnCursoSelect = {
    curso?: boolean | CursoArgs
    cursoId?: boolean
    destinatario?: boolean | DestinatariosArgs
    destinatarioId?: boolean
    descripcion?: boolean
    nombreMostrar?: boolean
  }

  export type DestinatarioOnCursoInclude = {
    curso?: boolean | CursoArgs
    destinatario?: boolean | DestinatariosArgs
  }

  export type DestinatarioOnCursoGetPayload<
    S extends boolean | null | undefined | DestinatarioOnCursoArgs,
    U = keyof S
      > = S extends true
        ? DestinatarioOnCurso
    : S extends undefined
    ? never
    : S extends DestinatarioOnCursoArgs | DestinatarioOnCursoFindManyArgs
    ?'include' extends U
    ? DestinatarioOnCurso  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'curso'
        ? CursoGetPayload<S['include'][P]> :
        P extends 'destinatario'
        ? DestinatariosGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DestinatarioOnCurso ?DestinatarioOnCurso [P]
  : 
          P extends 'curso'
        ? CursoGetPayload<S['select'][P]> :
        P extends 'destinatario'
        ? DestinatariosGetPayload<S['select'][P]> : never
  } 
    : DestinatarioOnCurso
  : DestinatarioOnCurso


  type DestinatarioOnCursoCountArgs = Merge<
    Omit<DestinatarioOnCursoFindManyArgs, 'select' | 'include'> & {
      select?: DestinatarioOnCursoCountAggregateInputType | true
    }
  >

  export interface DestinatarioOnCursoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DestinatarioOnCurso that matches the filter.
     * @param {DestinatarioOnCursoFindUniqueArgs} args - Arguments to find a DestinatarioOnCurso
     * @example
     * // Get one DestinatarioOnCurso
     * const destinatarioOnCurso = await prisma.destinatarioOnCurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DestinatarioOnCursoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DestinatarioOnCursoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DestinatarioOnCurso'> extends True ? CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso>, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T>>> : CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso | null >, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T> | null >>

    /**
     * Find the first DestinatarioOnCurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatarioOnCursoFindFirstArgs} args - Arguments to find a DestinatarioOnCurso
     * @example
     * // Get one DestinatarioOnCurso
     * const destinatarioOnCurso = await prisma.destinatarioOnCurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DestinatarioOnCursoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DestinatarioOnCursoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DestinatarioOnCurso'> extends True ? CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso>, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T>>> : CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso | null >, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T> | null >>

    /**
     * Find zero or more DestinatarioOnCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatarioOnCursoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DestinatarioOnCursos
     * const destinatarioOnCursos = await prisma.destinatarioOnCurso.findMany()
     * 
     * // Get first 10 DestinatarioOnCursos
     * const destinatarioOnCursos = await prisma.destinatarioOnCurso.findMany({ take: 10 })
     * 
     * // Only select the `cursoId`
     * const destinatarioOnCursoWithCursoIdOnly = await prisma.destinatarioOnCurso.findMany({ select: { cursoId: true } })
     * 
    **/
    findMany<T extends DestinatarioOnCursoFindManyArgs>(
      args?: SelectSubset<T, DestinatarioOnCursoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DestinatarioOnCurso>>, PrismaPromise<Array<DestinatarioOnCursoGetPayload<T>>>>

    /**
     * Create a DestinatarioOnCurso.
     * @param {DestinatarioOnCursoCreateArgs} args - Arguments to create a DestinatarioOnCurso.
     * @example
     * // Create one DestinatarioOnCurso
     * const DestinatarioOnCurso = await prisma.destinatarioOnCurso.create({
     *   data: {
     *     // ... data to create a DestinatarioOnCurso
     *   }
     * })
     * 
    **/
    create<T extends DestinatarioOnCursoCreateArgs>(
      args: SelectSubset<T, DestinatarioOnCursoCreateArgs>
    ): CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso>, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T>>>

    /**
     * Create many DestinatarioOnCursos.
     *     @param {DestinatarioOnCursoCreateManyArgs} args - Arguments to create many DestinatarioOnCursos.
     *     @example
     *     // Create many DestinatarioOnCursos
     *     const destinatarioOnCurso = await prisma.destinatarioOnCurso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DestinatarioOnCursoCreateManyArgs>(
      args?: SelectSubset<T, DestinatarioOnCursoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DestinatarioOnCurso.
     * @param {DestinatarioOnCursoDeleteArgs} args - Arguments to delete one DestinatarioOnCurso.
     * @example
     * // Delete one DestinatarioOnCurso
     * const DestinatarioOnCurso = await prisma.destinatarioOnCurso.delete({
     *   where: {
     *     // ... filter to delete one DestinatarioOnCurso
     *   }
     * })
     * 
    **/
    delete<T extends DestinatarioOnCursoDeleteArgs>(
      args: SelectSubset<T, DestinatarioOnCursoDeleteArgs>
    ): CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso>, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T>>>

    /**
     * Update one DestinatarioOnCurso.
     * @param {DestinatarioOnCursoUpdateArgs} args - Arguments to update one DestinatarioOnCurso.
     * @example
     * // Update one DestinatarioOnCurso
     * const destinatarioOnCurso = await prisma.destinatarioOnCurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DestinatarioOnCursoUpdateArgs>(
      args: SelectSubset<T, DestinatarioOnCursoUpdateArgs>
    ): CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso>, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T>>>

    /**
     * Delete zero or more DestinatarioOnCursos.
     * @param {DestinatarioOnCursoDeleteManyArgs} args - Arguments to filter DestinatarioOnCursos to delete.
     * @example
     * // Delete a few DestinatarioOnCursos
     * const { count } = await prisma.destinatarioOnCurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DestinatarioOnCursoDeleteManyArgs>(
      args?: SelectSubset<T, DestinatarioOnCursoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DestinatarioOnCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatarioOnCursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DestinatarioOnCursos
     * const destinatarioOnCurso = await prisma.destinatarioOnCurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DestinatarioOnCursoUpdateManyArgs>(
      args: SelectSubset<T, DestinatarioOnCursoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DestinatarioOnCurso.
     * @param {DestinatarioOnCursoUpsertArgs} args - Arguments to update or create a DestinatarioOnCurso.
     * @example
     * // Update or create a DestinatarioOnCurso
     * const destinatarioOnCurso = await prisma.destinatarioOnCurso.upsert({
     *   create: {
     *     // ... data to create a DestinatarioOnCurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DestinatarioOnCurso we want to update
     *   }
     * })
    **/
    upsert<T extends DestinatarioOnCursoUpsertArgs>(
      args: SelectSubset<T, DestinatarioOnCursoUpsertArgs>
    ): CheckSelect<T, Prisma__DestinatarioOnCursoClient<DestinatarioOnCurso>, Prisma__DestinatarioOnCursoClient<DestinatarioOnCursoGetPayload<T>>>

    /**
     * Count the number of DestinatarioOnCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatarioOnCursoCountArgs} args - Arguments to filter DestinatarioOnCursos to count.
     * @example
     * // Count the number of DestinatarioOnCursos
     * const count = await prisma.destinatarioOnCurso.count({
     *   where: {
     *     // ... the filter for the DestinatarioOnCursos we want to count
     *   }
     * })
    **/
    count<T extends DestinatarioOnCursoCountArgs>(
      args?: Subset<T, DestinatarioOnCursoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinatarioOnCursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DestinatarioOnCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatarioOnCursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinatarioOnCursoAggregateArgs>(args: Subset<T, DestinatarioOnCursoAggregateArgs>): PrismaPromise<GetDestinatarioOnCursoAggregateType<T>>

    /**
     * Group by DestinatarioOnCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatarioOnCursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinatarioOnCursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinatarioOnCursoGroupByArgs['orderBy'] }
        : { orderBy?: DestinatarioOnCursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinatarioOnCursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinatarioOnCursoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DestinatarioOnCurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DestinatarioOnCursoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    curso<T extends CursoArgs = {}>(args?: Subset<T, CursoArgs>): CheckSelect<T, Prisma__CursoClient<Curso | null >, Prisma__CursoClient<CursoGetPayload<T> | null >>;

    destinatario<T extends DestinatariosArgs = {}>(args?: Subset<T, DestinatariosArgs>): CheckSelect<T, Prisma__DestinatariosClient<Destinatarios | null >, Prisma__DestinatariosClient<DestinatariosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DestinatarioOnCurso findUnique
   */
  export type DestinatarioOnCursoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
    /**
     * Throw an Error if a DestinatarioOnCurso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DestinatarioOnCurso to fetch.
     * 
    **/
    where: DestinatarioOnCursoWhereUniqueInput
  }


  /**
   * DestinatarioOnCurso findFirst
   */
  export type DestinatarioOnCursoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
    /**
     * Throw an Error if a DestinatarioOnCurso can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DestinatarioOnCurso to fetch.
     * 
    **/
    where?: DestinatarioOnCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinatarioOnCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<DestinatarioOnCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DestinatarioOnCursos.
     * 
    **/
    cursor?: DestinatarioOnCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinatarioOnCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinatarioOnCursos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DestinatarioOnCursos.
     * 
    **/
    distinct?: Enumerable<DestinatarioOnCursoScalarFieldEnum>
  }


  /**
   * DestinatarioOnCurso findMany
   */
  export type DestinatarioOnCursoFindManyArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
    /**
     * Filter, which DestinatarioOnCursos to fetch.
     * 
    **/
    where?: DestinatarioOnCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DestinatarioOnCursos to fetch.
     * 
    **/
    orderBy?: Enumerable<DestinatarioOnCursoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DestinatarioOnCursos.
     * 
    **/
    cursor?: DestinatarioOnCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DestinatarioOnCursos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DestinatarioOnCursos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DestinatarioOnCursoScalarFieldEnum>
  }


  /**
   * DestinatarioOnCurso create
   */
  export type DestinatarioOnCursoCreateArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
    /**
     * The data needed to create a DestinatarioOnCurso.
     * 
    **/
    data: XOR<DestinatarioOnCursoCreateInput, DestinatarioOnCursoUncheckedCreateInput>
  }


  /**
   * DestinatarioOnCurso createMany
   */
  export type DestinatarioOnCursoCreateManyArgs = {
    data: Enumerable<DestinatarioOnCursoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DestinatarioOnCurso update
   */
  export type DestinatarioOnCursoUpdateArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
    /**
     * The data needed to update a DestinatarioOnCurso.
     * 
    **/
    data: XOR<DestinatarioOnCursoUpdateInput, DestinatarioOnCursoUncheckedUpdateInput>
    /**
     * Choose, which DestinatarioOnCurso to update.
     * 
    **/
    where: DestinatarioOnCursoWhereUniqueInput
  }


  /**
   * DestinatarioOnCurso updateMany
   */
  export type DestinatarioOnCursoUpdateManyArgs = {
    data: XOR<DestinatarioOnCursoUpdateManyMutationInput, DestinatarioOnCursoUncheckedUpdateManyInput>
    where?: DestinatarioOnCursoWhereInput
  }


  /**
   * DestinatarioOnCurso upsert
   */
  export type DestinatarioOnCursoUpsertArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
    /**
     * The filter to search for the DestinatarioOnCurso to update in case it exists.
     * 
    **/
    where: DestinatarioOnCursoWhereUniqueInput
    /**
     * In case the DestinatarioOnCurso found by the `where` argument doesn't exist, create a new DestinatarioOnCurso with this data.
     * 
    **/
    create: XOR<DestinatarioOnCursoCreateInput, DestinatarioOnCursoUncheckedCreateInput>
    /**
     * In case the DestinatarioOnCurso was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DestinatarioOnCursoUpdateInput, DestinatarioOnCursoUncheckedUpdateInput>
  }


  /**
   * DestinatarioOnCurso delete
   */
  export type DestinatarioOnCursoDeleteArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
    /**
     * Filter which DestinatarioOnCurso to delete.
     * 
    **/
    where: DestinatarioOnCursoWhereUniqueInput
  }


  /**
   * DestinatarioOnCurso deleteMany
   */
  export type DestinatarioOnCursoDeleteManyArgs = {
    where?: DestinatarioOnCursoWhereInput
  }


  /**
   * DestinatarioOnCurso without action
   */
  export type DestinatarioOnCursoArgs = {
    /**
     * Select specific fields to fetch from the DestinatarioOnCurso
     * 
    **/
    select?: DestinatarioOnCursoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatarioOnCursoInclude | null
  }



  /**
   * Model AlumnoOnCursoActivo
   */


  export type AggregateAlumnoOnCursoActivo = {
    _count: AlumnoOnCursoActivoCountAggregateOutputType | null
    count: AlumnoOnCursoActivoCountAggregateOutputType | null
    _avg: AlumnoOnCursoActivoAvgAggregateOutputType | null
    avg: AlumnoOnCursoActivoAvgAggregateOutputType | null
    _sum: AlumnoOnCursoActivoSumAggregateOutputType | null
    sum: AlumnoOnCursoActivoSumAggregateOutputType | null
    _min: AlumnoOnCursoActivoMinAggregateOutputType | null
    min: AlumnoOnCursoActivoMinAggregateOutputType | null
    _max: AlumnoOnCursoActivoMaxAggregateOutputType | null
    max: AlumnoOnCursoActivoMaxAggregateOutputType | null
  }

  export type AlumnoOnCursoActivoAvgAggregateOutputType = {
    cursoActivoId: number | null
    alumnoId: number | null
  }

  export type AlumnoOnCursoActivoSumAggregateOutputType = {
    cursoActivoId: number | null
    alumnoId: number | null
  }

  export type AlumnoOnCursoActivoMinAggregateOutputType = {
    cursoActivoId: number | null
    alumnoId: number | null
    descripcion: string | null
    nombreMostrar: string | null
  }

  export type AlumnoOnCursoActivoMaxAggregateOutputType = {
    cursoActivoId: number | null
    alumnoId: number | null
    descripcion: string | null
    nombreMostrar: string | null
  }

  export type AlumnoOnCursoActivoCountAggregateOutputType = {
    cursoActivoId: number
    alumnoId: number
    descripcion: number
    nombreMostrar: number
    _all: number
  }


  export type AlumnoOnCursoActivoAvgAggregateInputType = {
    cursoActivoId?: true
    alumnoId?: true
  }

  export type AlumnoOnCursoActivoSumAggregateInputType = {
    cursoActivoId?: true
    alumnoId?: true
  }

  export type AlumnoOnCursoActivoMinAggregateInputType = {
    cursoActivoId?: true
    alumnoId?: true
    descripcion?: true
    nombreMostrar?: true
  }

  export type AlumnoOnCursoActivoMaxAggregateInputType = {
    cursoActivoId?: true
    alumnoId?: true
    descripcion?: true
    nombreMostrar?: true
  }

  export type AlumnoOnCursoActivoCountAggregateInputType = {
    cursoActivoId?: true
    alumnoId?: true
    descripcion?: true
    nombreMostrar?: true
    _all?: true
  }

  export type AlumnoOnCursoActivoAggregateArgs = {
    /**
     * Filter which AlumnoOnCursoActivo to aggregate.
     * 
    **/
    where?: AlumnoOnCursoActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoOnCursoActivos to fetch.
     * 
    **/
    orderBy?: Enumerable<AlumnoOnCursoActivoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AlumnoOnCursoActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoOnCursoActivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoOnCursoActivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlumnoOnCursoActivos
    **/
    _count?: true | AlumnoOnCursoActivoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AlumnoOnCursoActivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlumnoOnCursoActivoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: AlumnoOnCursoActivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlumnoOnCursoActivoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: AlumnoOnCursoActivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumnoOnCursoActivoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AlumnoOnCursoActivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumnoOnCursoActivoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AlumnoOnCursoActivoMaxAggregateInputType
  }

  export type GetAlumnoOnCursoActivoAggregateType<T extends AlumnoOnCursoActivoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumnoOnCursoActivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumnoOnCursoActivo[P]>
      : GetScalarType<T[P], AggregateAlumnoOnCursoActivo[P]>
  }


    
    
  export type AlumnoOnCursoActivoGroupByArgs = {
    where?: AlumnoOnCursoActivoWhereInput
    orderBy?: Enumerable<AlumnoOnCursoActivoOrderByInput>
    by: Array<AlumnoOnCursoActivoScalarFieldEnum>
    having?: AlumnoOnCursoActivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumnoOnCursoActivoCountAggregateInputType | true
    _avg?: AlumnoOnCursoActivoAvgAggregateInputType
    _sum?: AlumnoOnCursoActivoSumAggregateInputType
    _min?: AlumnoOnCursoActivoMinAggregateInputType
    _max?: AlumnoOnCursoActivoMaxAggregateInputType
  }


  export type AlumnoOnCursoActivoGroupByOutputType = {
    cursoActivoId: number
    alumnoId: number
    descripcion: string
    nombreMostrar: string
    _count: AlumnoOnCursoActivoCountAggregateOutputType | null
    _avg: AlumnoOnCursoActivoAvgAggregateOutputType | null
    _sum: AlumnoOnCursoActivoSumAggregateOutputType | null
    _min: AlumnoOnCursoActivoMinAggregateOutputType | null
    _max: AlumnoOnCursoActivoMaxAggregateOutputType | null
  }

  type GetAlumnoOnCursoActivoGroupByPayload<T extends AlumnoOnCursoActivoGroupByArgs> = Promise<
    Array<
      PickArray<AlumnoOnCursoActivoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AlumnoOnCursoActivoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AlumnoOnCursoActivoGroupByOutputType[P]> 
            : GetScalarType<T[P], AlumnoOnCursoActivoGroupByOutputType[P]>
        }
      > 
    >


  export type AlumnoOnCursoActivoSelect = {
    cursoActivo?: boolean | CursosActivosArgs
    cursoActivoId?: boolean
    alumno?: boolean | AlumnoArgs
    alumnoId?: boolean
    descripcion?: boolean
    nombreMostrar?: boolean
  }

  export type AlumnoOnCursoActivoInclude = {
    cursoActivo?: boolean | CursosActivosArgs
    alumno?: boolean | AlumnoArgs
  }

  export type AlumnoOnCursoActivoGetPayload<
    S extends boolean | null | undefined | AlumnoOnCursoActivoArgs,
    U = keyof S
      > = S extends true
        ? AlumnoOnCursoActivo
    : S extends undefined
    ? never
    : S extends AlumnoOnCursoActivoArgs | AlumnoOnCursoActivoFindManyArgs
    ?'include' extends U
    ? AlumnoOnCursoActivo  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cursoActivo'
        ? CursosActivosGetPayload<S['include'][P]> :
        P extends 'alumno'
        ? AlumnoGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AlumnoOnCursoActivo ?AlumnoOnCursoActivo [P]
  : 
          P extends 'cursoActivo'
        ? CursosActivosGetPayload<S['select'][P]> :
        P extends 'alumno'
        ? AlumnoGetPayload<S['select'][P]> : never
  } 
    : AlumnoOnCursoActivo
  : AlumnoOnCursoActivo


  type AlumnoOnCursoActivoCountArgs = Merge<
    Omit<AlumnoOnCursoActivoFindManyArgs, 'select' | 'include'> & {
      select?: AlumnoOnCursoActivoCountAggregateInputType | true
    }
  >

  export interface AlumnoOnCursoActivoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AlumnoOnCursoActivo that matches the filter.
     * @param {AlumnoOnCursoActivoFindUniqueArgs} args - Arguments to find a AlumnoOnCursoActivo
     * @example
     * // Get one AlumnoOnCursoActivo
     * const alumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlumnoOnCursoActivoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlumnoOnCursoActivoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AlumnoOnCursoActivo'> extends True ? CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo>, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T>>> : CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo | null >, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T> | null >>

    /**
     * Find the first AlumnoOnCursoActivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoOnCursoActivoFindFirstArgs} args - Arguments to find a AlumnoOnCursoActivo
     * @example
     * // Get one AlumnoOnCursoActivo
     * const alumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlumnoOnCursoActivoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlumnoOnCursoActivoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AlumnoOnCursoActivo'> extends True ? CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo>, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T>>> : CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo | null >, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T> | null >>

    /**
     * Find zero or more AlumnoOnCursoActivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoOnCursoActivoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlumnoOnCursoActivos
     * const alumnoOnCursoActivos = await prisma.alumnoOnCursoActivo.findMany()
     * 
     * // Get first 10 AlumnoOnCursoActivos
     * const alumnoOnCursoActivos = await prisma.alumnoOnCursoActivo.findMany({ take: 10 })
     * 
     * // Only select the `cursoActivoId`
     * const alumnoOnCursoActivoWithCursoActivoIdOnly = await prisma.alumnoOnCursoActivo.findMany({ select: { cursoActivoId: true } })
     * 
    **/
    findMany<T extends AlumnoOnCursoActivoFindManyArgs>(
      args?: SelectSubset<T, AlumnoOnCursoActivoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AlumnoOnCursoActivo>>, PrismaPromise<Array<AlumnoOnCursoActivoGetPayload<T>>>>

    /**
     * Create a AlumnoOnCursoActivo.
     * @param {AlumnoOnCursoActivoCreateArgs} args - Arguments to create a AlumnoOnCursoActivo.
     * @example
     * // Create one AlumnoOnCursoActivo
     * const AlumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.create({
     *   data: {
     *     // ... data to create a AlumnoOnCursoActivo
     *   }
     * })
     * 
    **/
    create<T extends AlumnoOnCursoActivoCreateArgs>(
      args: SelectSubset<T, AlumnoOnCursoActivoCreateArgs>
    ): CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo>, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T>>>

    /**
     * Create many AlumnoOnCursoActivos.
     *     @param {AlumnoOnCursoActivoCreateManyArgs} args - Arguments to create many AlumnoOnCursoActivos.
     *     @example
     *     // Create many AlumnoOnCursoActivos
     *     const alumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlumnoOnCursoActivoCreateManyArgs>(
      args?: SelectSubset<T, AlumnoOnCursoActivoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AlumnoOnCursoActivo.
     * @param {AlumnoOnCursoActivoDeleteArgs} args - Arguments to delete one AlumnoOnCursoActivo.
     * @example
     * // Delete one AlumnoOnCursoActivo
     * const AlumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.delete({
     *   where: {
     *     // ... filter to delete one AlumnoOnCursoActivo
     *   }
     * })
     * 
    **/
    delete<T extends AlumnoOnCursoActivoDeleteArgs>(
      args: SelectSubset<T, AlumnoOnCursoActivoDeleteArgs>
    ): CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo>, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T>>>

    /**
     * Update one AlumnoOnCursoActivo.
     * @param {AlumnoOnCursoActivoUpdateArgs} args - Arguments to update one AlumnoOnCursoActivo.
     * @example
     * // Update one AlumnoOnCursoActivo
     * const alumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlumnoOnCursoActivoUpdateArgs>(
      args: SelectSubset<T, AlumnoOnCursoActivoUpdateArgs>
    ): CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo>, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T>>>

    /**
     * Delete zero or more AlumnoOnCursoActivos.
     * @param {AlumnoOnCursoActivoDeleteManyArgs} args - Arguments to filter AlumnoOnCursoActivos to delete.
     * @example
     * // Delete a few AlumnoOnCursoActivos
     * const { count } = await prisma.alumnoOnCursoActivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlumnoOnCursoActivoDeleteManyArgs>(
      args?: SelectSubset<T, AlumnoOnCursoActivoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlumnoOnCursoActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoOnCursoActivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlumnoOnCursoActivos
     * const alumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlumnoOnCursoActivoUpdateManyArgs>(
      args: SelectSubset<T, AlumnoOnCursoActivoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AlumnoOnCursoActivo.
     * @param {AlumnoOnCursoActivoUpsertArgs} args - Arguments to update or create a AlumnoOnCursoActivo.
     * @example
     * // Update or create a AlumnoOnCursoActivo
     * const alumnoOnCursoActivo = await prisma.alumnoOnCursoActivo.upsert({
     *   create: {
     *     // ... data to create a AlumnoOnCursoActivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlumnoOnCursoActivo we want to update
     *   }
     * })
    **/
    upsert<T extends AlumnoOnCursoActivoUpsertArgs>(
      args: SelectSubset<T, AlumnoOnCursoActivoUpsertArgs>
    ): CheckSelect<T, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivo>, Prisma__AlumnoOnCursoActivoClient<AlumnoOnCursoActivoGetPayload<T>>>

    /**
     * Count the number of AlumnoOnCursoActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoOnCursoActivoCountArgs} args - Arguments to filter AlumnoOnCursoActivos to count.
     * @example
     * // Count the number of AlumnoOnCursoActivos
     * const count = await prisma.alumnoOnCursoActivo.count({
     *   where: {
     *     // ... the filter for the AlumnoOnCursoActivos we want to count
     *   }
     * })
    **/
    count<T extends AlumnoOnCursoActivoCountArgs>(
      args?: Subset<T, AlumnoOnCursoActivoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumnoOnCursoActivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlumnoOnCursoActivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoOnCursoActivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumnoOnCursoActivoAggregateArgs>(args: Subset<T, AlumnoOnCursoActivoAggregateArgs>): PrismaPromise<GetAlumnoOnCursoActivoAggregateType<T>>

    /**
     * Group by AlumnoOnCursoActivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoOnCursoActivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlumnoOnCursoActivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumnoOnCursoActivoGroupByArgs['orderBy'] }
        : { orderBy?: AlumnoOnCursoActivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlumnoOnCursoActivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumnoOnCursoActivoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlumnoOnCursoActivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlumnoOnCursoActivoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cursoActivo<T extends CursosActivosArgs = {}>(args?: Subset<T, CursosActivosArgs>): CheckSelect<T, Prisma__CursosActivosClient<CursosActivos | null >, Prisma__CursosActivosClient<CursosActivosGetPayload<T> | null >>;

    alumno<T extends AlumnoArgs = {}>(args?: Subset<T, AlumnoArgs>): CheckSelect<T, Prisma__AlumnoClient<Alumno | null >, Prisma__AlumnoClient<AlumnoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AlumnoOnCursoActivo findUnique
   */
  export type AlumnoOnCursoActivoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
    /**
     * Throw an Error if a AlumnoOnCursoActivo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AlumnoOnCursoActivo to fetch.
     * 
    **/
    where: AlumnoOnCursoActivoWhereUniqueInput
  }


  /**
   * AlumnoOnCursoActivo findFirst
   */
  export type AlumnoOnCursoActivoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
    /**
     * Throw an Error if a AlumnoOnCursoActivo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AlumnoOnCursoActivo to fetch.
     * 
    **/
    where?: AlumnoOnCursoActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoOnCursoActivos to fetch.
     * 
    **/
    orderBy?: Enumerable<AlumnoOnCursoActivoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlumnoOnCursoActivos.
     * 
    **/
    cursor?: AlumnoOnCursoActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoOnCursoActivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoOnCursoActivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlumnoOnCursoActivos.
     * 
    **/
    distinct?: Enumerable<AlumnoOnCursoActivoScalarFieldEnum>
  }


  /**
   * AlumnoOnCursoActivo findMany
   */
  export type AlumnoOnCursoActivoFindManyArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
    /**
     * Filter, which AlumnoOnCursoActivos to fetch.
     * 
    **/
    where?: AlumnoOnCursoActivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlumnoOnCursoActivos to fetch.
     * 
    **/
    orderBy?: Enumerable<AlumnoOnCursoActivoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlumnoOnCursoActivos.
     * 
    **/
    cursor?: AlumnoOnCursoActivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlumnoOnCursoActivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlumnoOnCursoActivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AlumnoOnCursoActivoScalarFieldEnum>
  }


  /**
   * AlumnoOnCursoActivo create
   */
  export type AlumnoOnCursoActivoCreateArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
    /**
     * The data needed to create a AlumnoOnCursoActivo.
     * 
    **/
    data: XOR<AlumnoOnCursoActivoCreateInput, AlumnoOnCursoActivoUncheckedCreateInput>
  }


  /**
   * AlumnoOnCursoActivo createMany
   */
  export type AlumnoOnCursoActivoCreateManyArgs = {
    data: Enumerable<AlumnoOnCursoActivoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AlumnoOnCursoActivo update
   */
  export type AlumnoOnCursoActivoUpdateArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
    /**
     * The data needed to update a AlumnoOnCursoActivo.
     * 
    **/
    data: XOR<AlumnoOnCursoActivoUpdateInput, AlumnoOnCursoActivoUncheckedUpdateInput>
    /**
     * Choose, which AlumnoOnCursoActivo to update.
     * 
    **/
    where: AlumnoOnCursoActivoWhereUniqueInput
  }


  /**
   * AlumnoOnCursoActivo updateMany
   */
  export type AlumnoOnCursoActivoUpdateManyArgs = {
    data: XOR<AlumnoOnCursoActivoUpdateManyMutationInput, AlumnoOnCursoActivoUncheckedUpdateManyInput>
    where?: AlumnoOnCursoActivoWhereInput
  }


  /**
   * AlumnoOnCursoActivo upsert
   */
  export type AlumnoOnCursoActivoUpsertArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
    /**
     * The filter to search for the AlumnoOnCursoActivo to update in case it exists.
     * 
    **/
    where: AlumnoOnCursoActivoWhereUniqueInput
    /**
     * In case the AlumnoOnCursoActivo found by the `where` argument doesn't exist, create a new AlumnoOnCursoActivo with this data.
     * 
    **/
    create: XOR<AlumnoOnCursoActivoCreateInput, AlumnoOnCursoActivoUncheckedCreateInput>
    /**
     * In case the AlumnoOnCursoActivo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AlumnoOnCursoActivoUpdateInput, AlumnoOnCursoActivoUncheckedUpdateInput>
  }


  /**
   * AlumnoOnCursoActivo delete
   */
  export type AlumnoOnCursoActivoDeleteArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
    /**
     * Filter which AlumnoOnCursoActivo to delete.
     * 
    **/
    where: AlumnoOnCursoActivoWhereUniqueInput
  }


  /**
   * AlumnoOnCursoActivo deleteMany
   */
  export type AlumnoOnCursoActivoDeleteManyArgs = {
    where?: AlumnoOnCursoActivoWhereInput
  }


  /**
   * AlumnoOnCursoActivo without action
   */
  export type AlumnoOnCursoActivoArgs = {
    /**
     * Select specific fields to fetch from the AlumnoOnCursoActivo
     * 
    **/
    select?: AlumnoOnCursoActivoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoOnCursoActivoInclude | null
  }



  /**
   * Model Alumno
   */


  export type AggregateAlumno = {
    _count: AlumnoCountAggregateOutputType | null
    count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
    max: AlumnoMaxAggregateOutputType | null
  }

  export type AlumnoAvgAggregateOutputType = {
    id: number | null
    nroDocumento: number | null
    celular: number | null
    localidadId: number | null
  }

  export type AlumnoSumAggregateOutputType = {
    id: number | null
    nroDocumento: number | null
    celular: number | null
    localidadId: number | null
  }

  export type AlumnoMinAggregateOutputType = {
    id: number | null
    nroDocumento: number | null
    apellido: string | null
    nombre: string | null
    fechaNacimiento: Date | null
    email: string | null
    celular: number | null
    domicilio: string | null
    barrio: string | null
    localidadId: number | null
  }

  export type AlumnoMaxAggregateOutputType = {
    id: number | null
    nroDocumento: number | null
    apellido: string | null
    nombre: string | null
    fechaNacimiento: Date | null
    email: string | null
    celular: number | null
    domicilio: string | null
    barrio: string | null
    localidadId: number | null
  }

  export type AlumnoCountAggregateOutputType = {
    id: number
    nroDocumento: number
    apellido: number
    nombre: number
    fechaNacimiento: number
    email: number
    celular: number
    domicilio: number
    barrio: number
    localidadId: number
    _all: number
  }


  export type AlumnoAvgAggregateInputType = {
    id?: true
    nroDocumento?: true
    celular?: true
    localidadId?: true
  }

  export type AlumnoSumAggregateInputType = {
    id?: true
    nroDocumento?: true
    celular?: true
    localidadId?: true
  }

  export type AlumnoMinAggregateInputType = {
    id?: true
    nroDocumento?: true
    apellido?: true
    nombre?: true
    fechaNacimiento?: true
    email?: true
    celular?: true
    domicilio?: true
    barrio?: true
    localidadId?: true
  }

  export type AlumnoMaxAggregateInputType = {
    id?: true
    nroDocumento?: true
    apellido?: true
    nombre?: true
    fechaNacimiento?: true
    email?: true
    celular?: true
    domicilio?: true
    barrio?: true
    localidadId?: true
  }

  export type AlumnoCountAggregateInputType = {
    id?: true
    nroDocumento?: true
    apellido?: true
    nombre?: true
    fechaNacimiento?: true
    email?: true
    celular?: true
    domicilio?: true
    barrio?: true
    localidadId?: true
    _all?: true
  }

  export type AlumnoAggregateArgs = {
    /**
     * Filter which Alumno to aggregate.
     * 
    **/
    where?: AlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumnos to fetch.
     * 
    **/
    orderBy?: Enumerable<AlumnoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumnos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumnos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alumnos
    **/
    _count?: true | AlumnoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AlumnoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlumnoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: AlumnoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlumnoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: AlumnoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlumnoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AlumnoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlumnoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AlumnoMaxAggregateInputType
  }

  export type GetAlumnoAggregateType<T extends AlumnoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlumno]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlumno[P]>
      : GetScalarType<T[P], AggregateAlumno[P]>
  }


    
    
  export type AlumnoGroupByArgs = {
    where?: AlumnoWhereInput
    orderBy?: Enumerable<AlumnoOrderByInput>
    by: Array<AlumnoScalarFieldEnum>
    having?: AlumnoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlumnoCountAggregateInputType | true
    _avg?: AlumnoAvgAggregateInputType
    _sum?: AlumnoSumAggregateInputType
    _min?: AlumnoMinAggregateInputType
    _max?: AlumnoMaxAggregateInputType
  }


  export type AlumnoGroupByOutputType = {
    id: number
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date
    email: string
    celular: number
    domicilio: string
    barrio: string | null
    localidadId: number
    _count: AlumnoCountAggregateOutputType | null
    _avg: AlumnoAvgAggregateOutputType | null
    _sum: AlumnoSumAggregateOutputType | null
    _min: AlumnoMinAggregateOutputType | null
    _max: AlumnoMaxAggregateOutputType | null
  }

  type GetAlumnoGroupByPayload<T extends AlumnoGroupByArgs> = Promise<
    Array<
      PickArray<AlumnoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AlumnoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AlumnoGroupByOutputType[P]> 
            : GetScalarType<T[P], AlumnoGroupByOutputType[P]>
        }
      > 
    >


  export type AlumnoSelect = {
    id?: boolean
    nroDocumento?: boolean
    apellido?: boolean
    nombre?: boolean
    fechaNacimiento?: boolean
    email?: boolean
    celular?: boolean
    domicilio?: boolean
    barrio?: boolean
    localidad?: boolean | LocalidadArgs
    localidadId?: boolean
    cursoActivo?: boolean | AlumnoOnCursoActivoFindManyArgs
  }

  export type AlumnoInclude = {
    localidad?: boolean | LocalidadArgs
    cursoActivo?: boolean | AlumnoOnCursoActivoFindManyArgs
  }

  export type AlumnoGetPayload<
    S extends boolean | null | undefined | AlumnoArgs,
    U = keyof S
      > = S extends true
        ? Alumno
    : S extends undefined
    ? never
    : S extends AlumnoArgs | AlumnoFindManyArgs
    ?'include' extends U
    ? Alumno  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'localidad'
        ? LocalidadGetPayload<S['include'][P]> :
        P extends 'cursoActivo'
        ? Array < AlumnoOnCursoActivoGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Alumno ?Alumno [P]
  : 
          P extends 'localidad'
        ? LocalidadGetPayload<S['select'][P]> :
        P extends 'cursoActivo'
        ? Array < AlumnoOnCursoActivoGetPayload<S['select'][P]>>  : never
  } 
    : Alumno
  : Alumno


  type AlumnoCountArgs = Merge<
    Omit<AlumnoFindManyArgs, 'select' | 'include'> & {
      select?: AlumnoCountAggregateInputType | true
    }
  >

  export interface AlumnoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Alumno that matches the filter.
     * @param {AlumnoFindUniqueArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlumnoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlumnoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alumno'> extends True ? CheckSelect<T, Prisma__AlumnoClient<Alumno>, Prisma__AlumnoClient<AlumnoGetPayload<T>>> : CheckSelect<T, Prisma__AlumnoClient<Alumno | null >, Prisma__AlumnoClient<AlumnoGetPayload<T> | null >>

    /**
     * Find the first Alumno that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoFindFirstArgs} args - Arguments to find a Alumno
     * @example
     * // Get one Alumno
     * const alumno = await prisma.alumno.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlumnoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlumnoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alumno'> extends True ? CheckSelect<T, Prisma__AlumnoClient<Alumno>, Prisma__AlumnoClient<AlumnoGetPayload<T>>> : CheckSelect<T, Prisma__AlumnoClient<Alumno | null >, Prisma__AlumnoClient<AlumnoGetPayload<T> | null >>

    /**
     * Find zero or more Alumnos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alumnos
     * const alumnos = await prisma.alumno.findMany()
     * 
     * // Get first 10 Alumnos
     * const alumnos = await prisma.alumno.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alumnoWithIdOnly = await prisma.alumno.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlumnoFindManyArgs>(
      args?: SelectSubset<T, AlumnoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Alumno>>, PrismaPromise<Array<AlumnoGetPayload<T>>>>

    /**
     * Create a Alumno.
     * @param {AlumnoCreateArgs} args - Arguments to create a Alumno.
     * @example
     * // Create one Alumno
     * const Alumno = await prisma.alumno.create({
     *   data: {
     *     // ... data to create a Alumno
     *   }
     * })
     * 
    **/
    create<T extends AlumnoCreateArgs>(
      args: SelectSubset<T, AlumnoCreateArgs>
    ): CheckSelect<T, Prisma__AlumnoClient<Alumno>, Prisma__AlumnoClient<AlumnoGetPayload<T>>>

    /**
     * Create many Alumnos.
     *     @param {AlumnoCreateManyArgs} args - Arguments to create many Alumnos.
     *     @example
     *     // Create many Alumnos
     *     const alumno = await prisma.alumno.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlumnoCreateManyArgs>(
      args?: SelectSubset<T, AlumnoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Alumno.
     * @param {AlumnoDeleteArgs} args - Arguments to delete one Alumno.
     * @example
     * // Delete one Alumno
     * const Alumno = await prisma.alumno.delete({
     *   where: {
     *     // ... filter to delete one Alumno
     *   }
     * })
     * 
    **/
    delete<T extends AlumnoDeleteArgs>(
      args: SelectSubset<T, AlumnoDeleteArgs>
    ): CheckSelect<T, Prisma__AlumnoClient<Alumno>, Prisma__AlumnoClient<AlumnoGetPayload<T>>>

    /**
     * Update one Alumno.
     * @param {AlumnoUpdateArgs} args - Arguments to update one Alumno.
     * @example
     * // Update one Alumno
     * const alumno = await prisma.alumno.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlumnoUpdateArgs>(
      args: SelectSubset<T, AlumnoUpdateArgs>
    ): CheckSelect<T, Prisma__AlumnoClient<Alumno>, Prisma__AlumnoClient<AlumnoGetPayload<T>>>

    /**
     * Delete zero or more Alumnos.
     * @param {AlumnoDeleteManyArgs} args - Arguments to filter Alumnos to delete.
     * @example
     * // Delete a few Alumnos
     * const { count } = await prisma.alumno.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlumnoDeleteManyArgs>(
      args?: SelectSubset<T, AlumnoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alumnos
     * const alumno = await prisma.alumno.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlumnoUpdateManyArgs>(
      args: SelectSubset<T, AlumnoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Alumno.
     * @param {AlumnoUpsertArgs} args - Arguments to update or create a Alumno.
     * @example
     * // Update or create a Alumno
     * const alumno = await prisma.alumno.upsert({
     *   create: {
     *     // ... data to create a Alumno
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alumno we want to update
     *   }
     * })
    **/
    upsert<T extends AlumnoUpsertArgs>(
      args: SelectSubset<T, AlumnoUpsertArgs>
    ): CheckSelect<T, Prisma__AlumnoClient<Alumno>, Prisma__AlumnoClient<AlumnoGetPayload<T>>>

    /**
     * Count the number of Alumnos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoCountArgs} args - Arguments to filter Alumnos to count.
     * @example
     * // Count the number of Alumnos
     * const count = await prisma.alumno.count({
     *   where: {
     *     // ... the filter for the Alumnos we want to count
     *   }
     * })
    **/
    count<T extends AlumnoCountArgs>(
      args?: Subset<T, AlumnoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlumnoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlumnoAggregateArgs>(args: Subset<T, AlumnoAggregateArgs>): PrismaPromise<GetAlumnoAggregateType<T>>

    /**
     * Group by Alumno.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlumnoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlumnoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlumnoGroupByArgs['orderBy'] }
        : { orderBy?: AlumnoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlumnoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlumnoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alumno.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlumnoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    localidad<T extends LocalidadArgs = {}>(args?: Subset<T, LocalidadArgs>): CheckSelect<T, Prisma__LocalidadClient<Localidad | null >, Prisma__LocalidadClient<LocalidadGetPayload<T> | null >>;

    cursoActivo<T extends AlumnoOnCursoActivoFindManyArgs = {}>(args?: Subset<T, AlumnoOnCursoActivoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AlumnoOnCursoActivo>>, PrismaPromise<Array<AlumnoOnCursoActivoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Alumno findUnique
   */
  export type AlumnoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
    /**
     * Throw an Error if a Alumno can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Alumno to fetch.
     * 
    **/
    where: AlumnoWhereUniqueInput
  }


  /**
   * Alumno findFirst
   */
  export type AlumnoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
    /**
     * Throw an Error if a Alumno can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Alumno to fetch.
     * 
    **/
    where?: AlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumnos to fetch.
     * 
    **/
    orderBy?: Enumerable<AlumnoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alumnos.
     * 
    **/
    cursor?: AlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumnos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumnos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alumnos.
     * 
    **/
    distinct?: Enumerable<AlumnoScalarFieldEnum>
  }


  /**
   * Alumno findMany
   */
  export type AlumnoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
    /**
     * Filter, which Alumnos to fetch.
     * 
    **/
    where?: AlumnoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alumnos to fetch.
     * 
    **/
    orderBy?: Enumerable<AlumnoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alumnos.
     * 
    **/
    cursor?: AlumnoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alumnos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alumnos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AlumnoScalarFieldEnum>
  }


  /**
   * Alumno create
   */
  export type AlumnoCreateArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
    /**
     * The data needed to create a Alumno.
     * 
    **/
    data: XOR<AlumnoCreateInput, AlumnoUncheckedCreateInput>
  }


  /**
   * Alumno createMany
   */
  export type AlumnoCreateManyArgs = {
    data: Enumerable<AlumnoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alumno update
   */
  export type AlumnoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
    /**
     * The data needed to update a Alumno.
     * 
    **/
    data: XOR<AlumnoUpdateInput, AlumnoUncheckedUpdateInput>
    /**
     * Choose, which Alumno to update.
     * 
    **/
    where: AlumnoWhereUniqueInput
  }


  /**
   * Alumno updateMany
   */
  export type AlumnoUpdateManyArgs = {
    data: XOR<AlumnoUpdateManyMutationInput, AlumnoUncheckedUpdateManyInput>
    where?: AlumnoWhereInput
  }


  /**
   * Alumno upsert
   */
  export type AlumnoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
    /**
     * The filter to search for the Alumno to update in case it exists.
     * 
    **/
    where: AlumnoWhereUniqueInput
    /**
     * In case the Alumno found by the `where` argument doesn't exist, create a new Alumno with this data.
     * 
    **/
    create: XOR<AlumnoCreateInput, AlumnoUncheckedCreateInput>
    /**
     * In case the Alumno was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AlumnoUpdateInput, AlumnoUncheckedUpdateInput>
  }


  /**
   * Alumno delete
   */
  export type AlumnoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
    /**
     * Filter which Alumno to delete.
     * 
    **/
    where: AlumnoWhereUniqueInput
  }


  /**
   * Alumno deleteMany
   */
  export type AlumnoDeleteManyArgs = {
    where?: AlumnoWhereInput
  }


  /**
   * Alumno without action
   */
  export type AlumnoArgs = {
    /**
     * Select specific fields to fetch from the Alumno
     * 
    **/
    select?: AlumnoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AlumnoInclude | null
  }



  /**
   * Model Destinatarios
   */


  export type AggregateDestinatarios = {
    _count: DestinatariosCountAggregateOutputType | null
    count: DestinatariosCountAggregateOutputType | null
    _avg: DestinatariosAvgAggregateOutputType | null
    avg: DestinatariosAvgAggregateOutputType | null
    _sum: DestinatariosSumAggregateOutputType | null
    sum: DestinatariosSumAggregateOutputType | null
    _min: DestinatariosMinAggregateOutputType | null
    min: DestinatariosMinAggregateOutputType | null
    _max: DestinatariosMaxAggregateOutputType | null
    max: DestinatariosMaxAggregateOutputType | null
  }

  export type DestinatariosAvgAggregateOutputType = {
    id: number | null
  }

  export type DestinatariosSumAggregateOutputType = {
    id: number | null
  }

  export type DestinatariosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type DestinatariosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type DestinatariosCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type DestinatariosAvgAggregateInputType = {
    id?: true
  }

  export type DestinatariosSumAggregateInputType = {
    id?: true
  }

  export type DestinatariosMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type DestinatariosMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type DestinatariosCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type DestinatariosAggregateArgs = {
    /**
     * Filter which Destinatarios to aggregate.
     * 
    **/
    where?: DestinatariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinatarios to fetch.
     * 
    **/
    orderBy?: Enumerable<DestinatariosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DestinatariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinatarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinatarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Destinatarios
    **/
    _count?: true | DestinatariosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | DestinatariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinatariosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: DestinatariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinatariosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: DestinatariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinatariosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: DestinatariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinatariosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: DestinatariosMaxAggregateInputType
  }

  export type GetDestinatariosAggregateType<T extends DestinatariosAggregateArgs> = {
        [P in keyof T & keyof AggregateDestinatarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestinatarios[P]>
      : GetScalarType<T[P], AggregateDestinatarios[P]>
  }


    
    
  export type DestinatariosGroupByArgs = {
    where?: DestinatariosWhereInput
    orderBy?: Enumerable<DestinatariosOrderByInput>
    by: Array<DestinatariosScalarFieldEnum>
    having?: DestinatariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinatariosCountAggregateInputType | true
    _avg?: DestinatariosAvgAggregateInputType
    _sum?: DestinatariosSumAggregateInputType
    _min?: DestinatariosMinAggregateInputType
    _max?: DestinatariosMaxAggregateInputType
  }


  export type DestinatariosGroupByOutputType = {
    id: number
    nombre: string
    _count: DestinatariosCountAggregateOutputType | null
    _avg: DestinatariosAvgAggregateOutputType | null
    _sum: DestinatariosSumAggregateOutputType | null
    _min: DestinatariosMinAggregateOutputType | null
    _max: DestinatariosMaxAggregateOutputType | null
  }

  type GetDestinatariosGroupByPayload<T extends DestinatariosGroupByArgs> = Promise<
    Array<
      PickArray<DestinatariosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof DestinatariosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], DestinatariosGroupByOutputType[P]> 
            : GetScalarType<T[P], DestinatariosGroupByOutputType[P]>
        }
      > 
    >


  export type DestinatariosSelect = {
    id?: boolean
    nombre?: boolean
    cursos?: boolean | DestinatarioOnCursoFindManyArgs
  }

  export type DestinatariosInclude = {
    cursos?: boolean | DestinatarioOnCursoFindManyArgs
  }

  export type DestinatariosGetPayload<
    S extends boolean | null | undefined | DestinatariosArgs,
    U = keyof S
      > = S extends true
        ? Destinatarios
    : S extends undefined
    ? never
    : S extends DestinatariosArgs | DestinatariosFindManyArgs
    ?'include' extends U
    ? Destinatarios  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cursos'
        ? Array < DestinatarioOnCursoGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Destinatarios ?Destinatarios [P]
  : 
          P extends 'cursos'
        ? Array < DestinatarioOnCursoGetPayload<S['select'][P]>>  : never
  } 
    : Destinatarios
  : Destinatarios


  type DestinatariosCountArgs = Merge<
    Omit<DestinatariosFindManyArgs, 'select' | 'include'> & {
      select?: DestinatariosCountAggregateInputType | true
    }
  >

  export interface DestinatariosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Destinatarios that matches the filter.
     * @param {DestinatariosFindUniqueArgs} args - Arguments to find a Destinatarios
     * @example
     * // Get one Destinatarios
     * const destinatarios = await prisma.destinatarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DestinatariosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DestinatariosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Destinatarios'> extends True ? CheckSelect<T, Prisma__DestinatariosClient<Destinatarios>, Prisma__DestinatariosClient<DestinatariosGetPayload<T>>> : CheckSelect<T, Prisma__DestinatariosClient<Destinatarios | null >, Prisma__DestinatariosClient<DestinatariosGetPayload<T> | null >>

    /**
     * Find the first Destinatarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatariosFindFirstArgs} args - Arguments to find a Destinatarios
     * @example
     * // Get one Destinatarios
     * const destinatarios = await prisma.destinatarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DestinatariosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DestinatariosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Destinatarios'> extends True ? CheckSelect<T, Prisma__DestinatariosClient<Destinatarios>, Prisma__DestinatariosClient<DestinatariosGetPayload<T>>> : CheckSelect<T, Prisma__DestinatariosClient<Destinatarios | null >, Prisma__DestinatariosClient<DestinatariosGetPayload<T> | null >>

    /**
     * Find zero or more Destinatarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Destinatarios
     * const destinatarios = await prisma.destinatarios.findMany()
     * 
     * // Get first 10 Destinatarios
     * const destinatarios = await prisma.destinatarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinatariosWithIdOnly = await prisma.destinatarios.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DestinatariosFindManyArgs>(
      args?: SelectSubset<T, DestinatariosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Destinatarios>>, PrismaPromise<Array<DestinatariosGetPayload<T>>>>

    /**
     * Create a Destinatarios.
     * @param {DestinatariosCreateArgs} args - Arguments to create a Destinatarios.
     * @example
     * // Create one Destinatarios
     * const Destinatarios = await prisma.destinatarios.create({
     *   data: {
     *     // ... data to create a Destinatarios
     *   }
     * })
     * 
    **/
    create<T extends DestinatariosCreateArgs>(
      args: SelectSubset<T, DestinatariosCreateArgs>
    ): CheckSelect<T, Prisma__DestinatariosClient<Destinatarios>, Prisma__DestinatariosClient<DestinatariosGetPayload<T>>>

    /**
     * Create many Destinatarios.
     *     @param {DestinatariosCreateManyArgs} args - Arguments to create many Destinatarios.
     *     @example
     *     // Create many Destinatarios
     *     const destinatarios = await prisma.destinatarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DestinatariosCreateManyArgs>(
      args?: SelectSubset<T, DestinatariosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Destinatarios.
     * @param {DestinatariosDeleteArgs} args - Arguments to delete one Destinatarios.
     * @example
     * // Delete one Destinatarios
     * const Destinatarios = await prisma.destinatarios.delete({
     *   where: {
     *     // ... filter to delete one Destinatarios
     *   }
     * })
     * 
    **/
    delete<T extends DestinatariosDeleteArgs>(
      args: SelectSubset<T, DestinatariosDeleteArgs>
    ): CheckSelect<T, Prisma__DestinatariosClient<Destinatarios>, Prisma__DestinatariosClient<DestinatariosGetPayload<T>>>

    /**
     * Update one Destinatarios.
     * @param {DestinatariosUpdateArgs} args - Arguments to update one Destinatarios.
     * @example
     * // Update one Destinatarios
     * const destinatarios = await prisma.destinatarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DestinatariosUpdateArgs>(
      args: SelectSubset<T, DestinatariosUpdateArgs>
    ): CheckSelect<T, Prisma__DestinatariosClient<Destinatarios>, Prisma__DestinatariosClient<DestinatariosGetPayload<T>>>

    /**
     * Delete zero or more Destinatarios.
     * @param {DestinatariosDeleteManyArgs} args - Arguments to filter Destinatarios to delete.
     * @example
     * // Delete a few Destinatarios
     * const { count } = await prisma.destinatarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DestinatariosDeleteManyArgs>(
      args?: SelectSubset<T, DestinatariosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinatarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Destinatarios
     * const destinatarios = await prisma.destinatarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DestinatariosUpdateManyArgs>(
      args: SelectSubset<T, DestinatariosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Destinatarios.
     * @param {DestinatariosUpsertArgs} args - Arguments to update or create a Destinatarios.
     * @example
     * // Update or create a Destinatarios
     * const destinatarios = await prisma.destinatarios.upsert({
     *   create: {
     *     // ... data to create a Destinatarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Destinatarios we want to update
     *   }
     * })
    **/
    upsert<T extends DestinatariosUpsertArgs>(
      args: SelectSubset<T, DestinatariosUpsertArgs>
    ): CheckSelect<T, Prisma__DestinatariosClient<Destinatarios>, Prisma__DestinatariosClient<DestinatariosGetPayload<T>>>

    /**
     * Count the number of Destinatarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatariosCountArgs} args - Arguments to filter Destinatarios to count.
     * @example
     * // Count the number of Destinatarios
     * const count = await prisma.destinatarios.count({
     *   where: {
     *     // ... the filter for the Destinatarios we want to count
     *   }
     * })
    **/
    count<T extends DestinatariosCountArgs>(
      args?: Subset<T, DestinatariosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinatariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Destinatarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinatariosAggregateArgs>(args: Subset<T, DestinatariosAggregateArgs>): PrismaPromise<GetDestinatariosAggregateType<T>>

    /**
     * Group by Destinatarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinatariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinatariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinatariosGroupByArgs['orderBy'] }
        : { orderBy?: DestinatariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinatariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinatariosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Destinatarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DestinatariosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cursos<T extends DestinatarioOnCursoFindManyArgs = {}>(args?: Subset<T, DestinatarioOnCursoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DestinatarioOnCurso>>, PrismaPromise<Array<DestinatarioOnCursoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Destinatarios findUnique
   */
  export type DestinatariosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
    /**
     * Throw an Error if a Destinatarios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Destinatarios to fetch.
     * 
    **/
    where: DestinatariosWhereUniqueInput
  }


  /**
   * Destinatarios findFirst
   */
  export type DestinatariosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
    /**
     * Throw an Error if a Destinatarios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Destinatarios to fetch.
     * 
    **/
    where?: DestinatariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinatarios to fetch.
     * 
    **/
    orderBy?: Enumerable<DestinatariosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinatarios.
     * 
    **/
    cursor?: DestinatariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinatarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinatarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinatarios.
     * 
    **/
    distinct?: Enumerable<DestinatariosScalarFieldEnum>
  }


  /**
   * Destinatarios findMany
   */
  export type DestinatariosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
    /**
     * Filter, which Destinatarios to fetch.
     * 
    **/
    where?: DestinatariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinatarios to fetch.
     * 
    **/
    orderBy?: Enumerable<DestinatariosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Destinatarios.
     * 
    **/
    cursor?: DestinatariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinatarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinatarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DestinatariosScalarFieldEnum>
  }


  /**
   * Destinatarios create
   */
  export type DestinatariosCreateArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
    /**
     * The data needed to create a Destinatarios.
     * 
    **/
    data: XOR<DestinatariosCreateInput, DestinatariosUncheckedCreateInput>
  }


  /**
   * Destinatarios createMany
   */
  export type DestinatariosCreateManyArgs = {
    data: Enumerable<DestinatariosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Destinatarios update
   */
  export type DestinatariosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
    /**
     * The data needed to update a Destinatarios.
     * 
    **/
    data: XOR<DestinatariosUpdateInput, DestinatariosUncheckedUpdateInput>
    /**
     * Choose, which Destinatarios to update.
     * 
    **/
    where: DestinatariosWhereUniqueInput
  }


  /**
   * Destinatarios updateMany
   */
  export type DestinatariosUpdateManyArgs = {
    data: XOR<DestinatariosUpdateManyMutationInput, DestinatariosUncheckedUpdateManyInput>
    where?: DestinatariosWhereInput
  }


  /**
   * Destinatarios upsert
   */
  export type DestinatariosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
    /**
     * The filter to search for the Destinatarios to update in case it exists.
     * 
    **/
    where: DestinatariosWhereUniqueInput
    /**
     * In case the Destinatarios found by the `where` argument doesn't exist, create a new Destinatarios with this data.
     * 
    **/
    create: XOR<DestinatariosCreateInput, DestinatariosUncheckedCreateInput>
    /**
     * In case the Destinatarios was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DestinatariosUpdateInput, DestinatariosUncheckedUpdateInput>
  }


  /**
   * Destinatarios delete
   */
  export type DestinatariosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
    /**
     * Filter which Destinatarios to delete.
     * 
    **/
    where: DestinatariosWhereUniqueInput
  }


  /**
   * Destinatarios deleteMany
   */
  export type DestinatariosDeleteManyArgs = {
    where?: DestinatariosWhereInput
  }


  /**
   * Destinatarios without action
   */
  export type DestinatariosArgs = {
    /**
     * Select specific fields to fetch from the Destinatarios
     * 
    **/
    select?: DestinatariosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DestinatariosInclude | null
  }



  /**
   * Model Salas
   */


  export type AggregateSalas = {
    _count: SalasCountAggregateOutputType | null
    count: SalasCountAggregateOutputType | null
    _avg: SalasAvgAggregateOutputType | null
    avg: SalasAvgAggregateOutputType | null
    _sum: SalasSumAggregateOutputType | null
    sum: SalasSumAggregateOutputType | null
    _min: SalasMinAggregateOutputType | null
    min: SalasMinAggregateOutputType | null
    _max: SalasMaxAggregateOutputType | null
    max: SalasMaxAggregateOutputType | null
  }

  export type SalasAvgAggregateOutputType = {
    id: number | null
    localidadId: number | null
  }

  export type SalasSumAggregateOutputType = {
    id: number | null
    localidadId: number | null
  }

  export type SalasMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    localidadId: number | null
  }

  export type SalasMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    localidadId: number | null
  }

  export type SalasCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    localidadId: number
    _all: number
  }


  export type SalasAvgAggregateInputType = {
    id?: true
    localidadId?: true
  }

  export type SalasSumAggregateInputType = {
    id?: true
    localidadId?: true
  }

  export type SalasMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    localidadId?: true
  }

  export type SalasMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    localidadId?: true
  }

  export type SalasCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    localidadId?: true
    _all?: true
  }

  export type SalasAggregateArgs = {
    /**
     * Filter which Salas to aggregate.
     * 
    **/
    where?: SalasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salas to fetch.
     * 
    **/
    orderBy?: Enumerable<SalasOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SalasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salas
    **/
    _count?: true | SalasCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SalasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalasAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: SalasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalasSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: SalasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalasMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SalasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalasMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SalasMaxAggregateInputType
  }

  export type GetSalasAggregateType<T extends SalasAggregateArgs> = {
        [P in keyof T & keyof AggregateSalas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalas[P]>
      : GetScalarType<T[P], AggregateSalas[P]>
  }


    
    
  export type SalasGroupByArgs = {
    where?: SalasWhereInput
    orderBy?: Enumerable<SalasOrderByInput>
    by: Array<SalasScalarFieldEnum>
    having?: SalasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalasCountAggregateInputType | true
    _avg?: SalasAvgAggregateInputType
    _sum?: SalasSumAggregateInputType
    _min?: SalasMinAggregateInputType
    _max?: SalasMaxAggregateInputType
  }


  export type SalasGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    localidadId: number
    _count: SalasCountAggregateOutputType | null
    _avg: SalasAvgAggregateOutputType | null
    _sum: SalasSumAggregateOutputType | null
    _min: SalasMinAggregateOutputType | null
    _max: SalasMaxAggregateOutputType | null
  }

  type GetSalasGroupByPayload<T extends SalasGroupByArgs> = Promise<
    Array<
      PickArray<SalasGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SalasGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SalasGroupByOutputType[P]> 
            : GetScalarType<T[P], SalasGroupByOutputType[P]>
        }
      > 
    >


  export type SalasSelect = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    localidad?: boolean | LocalidadArgs
    localidadId?: boolean
    cursosActivos?: boolean | CursosActivosArgs
  }

  export type SalasInclude = {
    localidad?: boolean | LocalidadArgs
    cursosActivos?: boolean | CursosActivosArgs
  }

  export type SalasGetPayload<
    S extends boolean | null | undefined | SalasArgs,
    U = keyof S
      > = S extends true
        ? Salas
    : S extends undefined
    ? never
    : S extends SalasArgs | SalasFindManyArgs
    ?'include' extends U
    ? Salas  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'localidad'
        ? LocalidadGetPayload<S['include'][P]> :
        P extends 'cursosActivos'
        ? CursosActivosGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Salas ?Salas [P]
  : 
          P extends 'localidad'
        ? LocalidadGetPayload<S['select'][P]> :
        P extends 'cursosActivos'
        ? CursosActivosGetPayload<S['select'][P]> | null : never
  } 
    : Salas
  : Salas


  type SalasCountArgs = Merge<
    Omit<SalasFindManyArgs, 'select' | 'include'> & {
      select?: SalasCountAggregateInputType | true
    }
  >

  export interface SalasDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Salas that matches the filter.
     * @param {SalasFindUniqueArgs} args - Arguments to find a Salas
     * @example
     * // Get one Salas
     * const salas = await prisma.salas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SalasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SalasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Salas'> extends True ? CheckSelect<T, Prisma__SalasClient<Salas>, Prisma__SalasClient<SalasGetPayload<T>>> : CheckSelect<T, Prisma__SalasClient<Salas | null >, Prisma__SalasClient<SalasGetPayload<T> | null >>

    /**
     * Find the first Salas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalasFindFirstArgs} args - Arguments to find a Salas
     * @example
     * // Get one Salas
     * const salas = await prisma.salas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SalasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SalasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Salas'> extends True ? CheckSelect<T, Prisma__SalasClient<Salas>, Prisma__SalasClient<SalasGetPayload<T>>> : CheckSelect<T, Prisma__SalasClient<Salas | null >, Prisma__SalasClient<SalasGetPayload<T> | null >>

    /**
     * Find zero or more Salas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salas
     * const salas = await prisma.salas.findMany()
     * 
     * // Get first 10 Salas
     * const salas = await prisma.salas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salasWithIdOnly = await prisma.salas.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SalasFindManyArgs>(
      args?: SelectSubset<T, SalasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Salas>>, PrismaPromise<Array<SalasGetPayload<T>>>>

    /**
     * Create a Salas.
     * @param {SalasCreateArgs} args - Arguments to create a Salas.
     * @example
     * // Create one Salas
     * const Salas = await prisma.salas.create({
     *   data: {
     *     // ... data to create a Salas
     *   }
     * })
     * 
    **/
    create<T extends SalasCreateArgs>(
      args: SelectSubset<T, SalasCreateArgs>
    ): CheckSelect<T, Prisma__SalasClient<Salas>, Prisma__SalasClient<SalasGetPayload<T>>>

    /**
     * Create many Salas.
     *     @param {SalasCreateManyArgs} args - Arguments to create many Salas.
     *     @example
     *     // Create many Salas
     *     const salas = await prisma.salas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SalasCreateManyArgs>(
      args?: SelectSubset<T, SalasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Salas.
     * @param {SalasDeleteArgs} args - Arguments to delete one Salas.
     * @example
     * // Delete one Salas
     * const Salas = await prisma.salas.delete({
     *   where: {
     *     // ... filter to delete one Salas
     *   }
     * })
     * 
    **/
    delete<T extends SalasDeleteArgs>(
      args: SelectSubset<T, SalasDeleteArgs>
    ): CheckSelect<T, Prisma__SalasClient<Salas>, Prisma__SalasClient<SalasGetPayload<T>>>

    /**
     * Update one Salas.
     * @param {SalasUpdateArgs} args - Arguments to update one Salas.
     * @example
     * // Update one Salas
     * const salas = await prisma.salas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SalasUpdateArgs>(
      args: SelectSubset<T, SalasUpdateArgs>
    ): CheckSelect<T, Prisma__SalasClient<Salas>, Prisma__SalasClient<SalasGetPayload<T>>>

    /**
     * Delete zero or more Salas.
     * @param {SalasDeleteManyArgs} args - Arguments to filter Salas to delete.
     * @example
     * // Delete a few Salas
     * const { count } = await prisma.salas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SalasDeleteManyArgs>(
      args?: SelectSubset<T, SalasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salas
     * const salas = await prisma.salas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SalasUpdateManyArgs>(
      args: SelectSubset<T, SalasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Salas.
     * @param {SalasUpsertArgs} args - Arguments to update or create a Salas.
     * @example
     * // Update or create a Salas
     * const salas = await prisma.salas.upsert({
     *   create: {
     *     // ... data to create a Salas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salas we want to update
     *   }
     * })
    **/
    upsert<T extends SalasUpsertArgs>(
      args: SelectSubset<T, SalasUpsertArgs>
    ): CheckSelect<T, Prisma__SalasClient<Salas>, Prisma__SalasClient<SalasGetPayload<T>>>

    /**
     * Count the number of Salas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalasCountArgs} args - Arguments to filter Salas to count.
     * @example
     * // Count the number of Salas
     * const count = await prisma.salas.count({
     *   where: {
     *     // ... the filter for the Salas we want to count
     *   }
     * })
    **/
    count<T extends SalasCountArgs>(
      args?: Subset<T, SalasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalasAggregateArgs>(args: Subset<T, SalasAggregateArgs>): PrismaPromise<GetSalasAggregateType<T>>

    /**
     * Group by Salas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalasGroupByArgs['orderBy'] }
        : { orderBy?: SalasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalasGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SalasClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    localidad<T extends LocalidadArgs = {}>(args?: Subset<T, LocalidadArgs>): CheckSelect<T, Prisma__LocalidadClient<Localidad | null >, Prisma__LocalidadClient<LocalidadGetPayload<T> | null >>;

    cursosActivos<T extends CursosActivosArgs = {}>(args?: Subset<T, CursosActivosArgs>): CheckSelect<T, Prisma__CursosActivosClient<CursosActivos | null >, Prisma__CursosActivosClient<CursosActivosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Salas findUnique
   */
  export type SalasFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
    /**
     * Throw an Error if a Salas can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Salas to fetch.
     * 
    **/
    where: SalasWhereUniqueInput
  }


  /**
   * Salas findFirst
   */
  export type SalasFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
    /**
     * Throw an Error if a Salas can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Salas to fetch.
     * 
    **/
    where?: SalasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salas to fetch.
     * 
    **/
    orderBy?: Enumerable<SalasOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salas.
     * 
    **/
    cursor?: SalasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salas.
     * 
    **/
    distinct?: Enumerable<SalasScalarFieldEnum>
  }


  /**
   * Salas findMany
   */
  export type SalasFindManyArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
    /**
     * Filter, which Salas to fetch.
     * 
    **/
    where?: SalasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salas to fetch.
     * 
    **/
    orderBy?: Enumerable<SalasOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salas.
     * 
    **/
    cursor?: SalasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SalasScalarFieldEnum>
  }


  /**
   * Salas create
   */
  export type SalasCreateArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
    /**
     * The data needed to create a Salas.
     * 
    **/
    data: XOR<SalasCreateInput, SalasUncheckedCreateInput>
  }


  /**
   * Salas createMany
   */
  export type SalasCreateManyArgs = {
    data: Enumerable<SalasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Salas update
   */
  export type SalasUpdateArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
    /**
     * The data needed to update a Salas.
     * 
    **/
    data: XOR<SalasUpdateInput, SalasUncheckedUpdateInput>
    /**
     * Choose, which Salas to update.
     * 
    **/
    where: SalasWhereUniqueInput
  }


  /**
   * Salas updateMany
   */
  export type SalasUpdateManyArgs = {
    data: XOR<SalasUpdateManyMutationInput, SalasUncheckedUpdateManyInput>
    where?: SalasWhereInput
  }


  /**
   * Salas upsert
   */
  export type SalasUpsertArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
    /**
     * The filter to search for the Salas to update in case it exists.
     * 
    **/
    where: SalasWhereUniqueInput
    /**
     * In case the Salas found by the `where` argument doesn't exist, create a new Salas with this data.
     * 
    **/
    create: XOR<SalasCreateInput, SalasUncheckedCreateInput>
    /**
     * In case the Salas was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SalasUpdateInput, SalasUncheckedUpdateInput>
  }


  /**
   * Salas delete
   */
  export type SalasDeleteArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
    /**
     * Filter which Salas to delete.
     * 
    **/
    where: SalasWhereUniqueInput
  }


  /**
   * Salas deleteMany
   */
  export type SalasDeleteManyArgs = {
    where?: SalasWhereInput
  }


  /**
   * Salas without action
   */
  export type SalasArgs = {
    /**
     * Select specific fields to fetch from the Salas
     * 
    **/
    select?: SalasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SalasInclude | null
  }



  /**
   * Model CursosActivos
   */


  export type AggregateCursosActivos = {
    _count: CursosActivosCountAggregateOutputType | null
    count: CursosActivosCountAggregateOutputType | null
    _avg: CursosActivosAvgAggregateOutputType | null
    avg: CursosActivosAvgAggregateOutputType | null
    _sum: CursosActivosSumAggregateOutputType | null
    sum: CursosActivosSumAggregateOutputType | null
    _min: CursosActivosMinAggregateOutputType | null
    min: CursosActivosMinAggregateOutputType | null
    _max: CursosActivosMaxAggregateOutputType | null
    max: CursosActivosMaxAggregateOutputType | null
  }

  export type CursosActivosAvgAggregateOutputType = {
    id: number | null
    cupos: number | null
    salaId: number | null
    localidadId: number | null
    cursoId: number | null
  }

  export type CursosActivosSumAggregateOutputType = {
    id: number | null
    cupos: number | null
    salaId: number | null
    localidadId: number | null
    cursoId: number | null
  }

  export type CursosActivosMinAggregateOutputType = {
    id: number | null
    nombreMostrar: string | null
    activo: boolean | null
    fechaInicio: Date | null
    fechaFin: Date | null
    horario: string | null
    cupos: number | null
    descripcion: string | null
    salaId: number | null
    localidadId: number | null
    cursoId: number | null
  }

  export type CursosActivosMaxAggregateOutputType = {
    id: number | null
    nombreMostrar: string | null
    activo: boolean | null
    fechaInicio: Date | null
    fechaFin: Date | null
    horario: string | null
    cupos: number | null
    descripcion: string | null
    salaId: number | null
    localidadId: number | null
    cursoId: number | null
  }

  export type CursosActivosCountAggregateOutputType = {
    id: number
    nombreMostrar: number
    activo: number
    fechaInicio: number
    fechaFin: number
    horario: number
    cupos: number
    descripcion: number
    salaId: number
    localidadId: number
    cursoId: number
    _all: number
  }


  export type CursosActivosAvgAggregateInputType = {
    id?: true
    cupos?: true
    salaId?: true
    localidadId?: true
    cursoId?: true
  }

  export type CursosActivosSumAggregateInputType = {
    id?: true
    cupos?: true
    salaId?: true
    localidadId?: true
    cursoId?: true
  }

  export type CursosActivosMinAggregateInputType = {
    id?: true
    nombreMostrar?: true
    activo?: true
    fechaInicio?: true
    fechaFin?: true
    horario?: true
    cupos?: true
    descripcion?: true
    salaId?: true
    localidadId?: true
    cursoId?: true
  }

  export type CursosActivosMaxAggregateInputType = {
    id?: true
    nombreMostrar?: true
    activo?: true
    fechaInicio?: true
    fechaFin?: true
    horario?: true
    cupos?: true
    descripcion?: true
    salaId?: true
    localidadId?: true
    cursoId?: true
  }

  export type CursosActivosCountAggregateInputType = {
    id?: true
    nombreMostrar?: true
    activo?: true
    fechaInicio?: true
    fechaFin?: true
    horario?: true
    cupos?: true
    descripcion?: true
    salaId?: true
    localidadId?: true
    cursoId?: true
    _all?: true
  }

  export type CursosActivosAggregateArgs = {
    /**
     * Filter which CursosActivos to aggregate.
     * 
    **/
    where?: CursosActivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursosActivos to fetch.
     * 
    **/
    orderBy?: Enumerable<CursosActivosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CursosActivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursosActivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursosActivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CursosActivos
    **/
    _count?: true | CursosActivosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CursosActivosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursosActivosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CursosActivosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursosActivosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CursosActivosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursosActivosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CursosActivosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursosActivosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CursosActivosMaxAggregateInputType
  }

  export type GetCursosActivosAggregateType<T extends CursosActivosAggregateArgs> = {
        [P in keyof T & keyof AggregateCursosActivos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCursosActivos[P]>
      : GetScalarType<T[P], AggregateCursosActivos[P]>
  }


    
    
  export type CursosActivosGroupByArgs = {
    where?: CursosActivosWhereInput
    orderBy?: Enumerable<CursosActivosOrderByInput>
    by: Array<CursosActivosScalarFieldEnum>
    having?: CursosActivosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursosActivosCountAggregateInputType | true
    _avg?: CursosActivosAvgAggregateInputType
    _sum?: CursosActivosSumAggregateInputType
    _min?: CursosActivosMinAggregateInputType
    _max?: CursosActivosMaxAggregateInputType
  }


  export type CursosActivosGroupByOutputType = {
    id: number
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date
    fechaFin: Date
    horario: string
    cupos: number
    descripcion: string
    salaId: number | null
    localidadId: number | null
    cursoId: number | null
    _count: CursosActivosCountAggregateOutputType | null
    _avg: CursosActivosAvgAggregateOutputType | null
    _sum: CursosActivosSumAggregateOutputType | null
    _min: CursosActivosMinAggregateOutputType | null
    _max: CursosActivosMaxAggregateOutputType | null
  }

  type GetCursosActivosGroupByPayload<T extends CursosActivosGroupByArgs> = Promise<
    Array<
      PickArray<CursosActivosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CursosActivosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CursosActivosGroupByOutputType[P]> 
            : GetScalarType<T[P], CursosActivosGroupByOutputType[P]>
        }
      > 
    >


  export type CursosActivosSelect = {
    id?: boolean
    nombreMostrar?: boolean
    activo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    horario?: boolean
    cupos?: boolean
    descripcion?: boolean
    sala?: boolean | SalasArgs
    salaId?: boolean
    alumnos?: boolean | AlumnoOnCursoActivoFindManyArgs
    localidadCurso?: boolean | LocalidadOnCursoArgs
    localidadId?: boolean
    cursoId?: boolean
  }

  export type CursosActivosInclude = {
    sala?: boolean | SalasArgs
    alumnos?: boolean | AlumnoOnCursoActivoFindManyArgs
    localidadCurso?: boolean | LocalidadOnCursoArgs
  }

  export type CursosActivosGetPayload<
    S extends boolean | null | undefined | CursosActivosArgs,
    U = keyof S
      > = S extends true
        ? CursosActivos
    : S extends undefined
    ? never
    : S extends CursosActivosArgs | CursosActivosFindManyArgs
    ?'include' extends U
    ? CursosActivos  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'sala'
        ? SalasGetPayload<S['include'][P]> | null :
        P extends 'alumnos'
        ? Array < AlumnoOnCursoActivoGetPayload<S['include'][P]>>  :
        P extends 'localidadCurso'
        ? LocalidadOnCursoGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CursosActivos ?CursosActivos [P]
  : 
          P extends 'sala'
        ? SalasGetPayload<S['select'][P]> | null :
        P extends 'alumnos'
        ? Array < AlumnoOnCursoActivoGetPayload<S['select'][P]>>  :
        P extends 'localidadCurso'
        ? LocalidadOnCursoGetPayload<S['select'][P]> | null : never
  } 
    : CursosActivos
  : CursosActivos


  type CursosActivosCountArgs = Merge<
    Omit<CursosActivosFindManyArgs, 'select' | 'include'> & {
      select?: CursosActivosCountAggregateInputType | true
    }
  >

  export interface CursosActivosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CursosActivos that matches the filter.
     * @param {CursosActivosFindUniqueArgs} args - Arguments to find a CursosActivos
     * @example
     * // Get one CursosActivos
     * const cursosActivos = await prisma.cursosActivos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CursosActivosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CursosActivosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CursosActivos'> extends True ? CheckSelect<T, Prisma__CursosActivosClient<CursosActivos>, Prisma__CursosActivosClient<CursosActivosGetPayload<T>>> : CheckSelect<T, Prisma__CursosActivosClient<CursosActivos | null >, Prisma__CursosActivosClient<CursosActivosGetPayload<T> | null >>

    /**
     * Find the first CursosActivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosActivosFindFirstArgs} args - Arguments to find a CursosActivos
     * @example
     * // Get one CursosActivos
     * const cursosActivos = await prisma.cursosActivos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CursosActivosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CursosActivosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CursosActivos'> extends True ? CheckSelect<T, Prisma__CursosActivosClient<CursosActivos>, Prisma__CursosActivosClient<CursosActivosGetPayload<T>>> : CheckSelect<T, Prisma__CursosActivosClient<CursosActivos | null >, Prisma__CursosActivosClient<CursosActivosGetPayload<T> | null >>

    /**
     * Find zero or more CursosActivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosActivosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CursosActivos
     * const cursosActivos = await prisma.cursosActivos.findMany()
     * 
     * // Get first 10 CursosActivos
     * const cursosActivos = await prisma.cursosActivos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursosActivosWithIdOnly = await prisma.cursosActivos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CursosActivosFindManyArgs>(
      args?: SelectSubset<T, CursosActivosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CursosActivos>>, PrismaPromise<Array<CursosActivosGetPayload<T>>>>

    /**
     * Create a CursosActivos.
     * @param {CursosActivosCreateArgs} args - Arguments to create a CursosActivos.
     * @example
     * // Create one CursosActivos
     * const CursosActivos = await prisma.cursosActivos.create({
     *   data: {
     *     // ... data to create a CursosActivos
     *   }
     * })
     * 
    **/
    create<T extends CursosActivosCreateArgs>(
      args: SelectSubset<T, CursosActivosCreateArgs>
    ): CheckSelect<T, Prisma__CursosActivosClient<CursosActivos>, Prisma__CursosActivosClient<CursosActivosGetPayload<T>>>

    /**
     * Create many CursosActivos.
     *     @param {CursosActivosCreateManyArgs} args - Arguments to create many CursosActivos.
     *     @example
     *     // Create many CursosActivos
     *     const cursosActivos = await prisma.cursosActivos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CursosActivosCreateManyArgs>(
      args?: SelectSubset<T, CursosActivosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CursosActivos.
     * @param {CursosActivosDeleteArgs} args - Arguments to delete one CursosActivos.
     * @example
     * // Delete one CursosActivos
     * const CursosActivos = await prisma.cursosActivos.delete({
     *   where: {
     *     // ... filter to delete one CursosActivos
     *   }
     * })
     * 
    **/
    delete<T extends CursosActivosDeleteArgs>(
      args: SelectSubset<T, CursosActivosDeleteArgs>
    ): CheckSelect<T, Prisma__CursosActivosClient<CursosActivos>, Prisma__CursosActivosClient<CursosActivosGetPayload<T>>>

    /**
     * Update one CursosActivos.
     * @param {CursosActivosUpdateArgs} args - Arguments to update one CursosActivos.
     * @example
     * // Update one CursosActivos
     * const cursosActivos = await prisma.cursosActivos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CursosActivosUpdateArgs>(
      args: SelectSubset<T, CursosActivosUpdateArgs>
    ): CheckSelect<T, Prisma__CursosActivosClient<CursosActivos>, Prisma__CursosActivosClient<CursosActivosGetPayload<T>>>

    /**
     * Delete zero or more CursosActivos.
     * @param {CursosActivosDeleteManyArgs} args - Arguments to filter CursosActivos to delete.
     * @example
     * // Delete a few CursosActivos
     * const { count } = await prisma.cursosActivos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CursosActivosDeleteManyArgs>(
      args?: SelectSubset<T, CursosActivosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CursosActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosActivosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CursosActivos
     * const cursosActivos = await prisma.cursosActivos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CursosActivosUpdateManyArgs>(
      args: SelectSubset<T, CursosActivosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CursosActivos.
     * @param {CursosActivosUpsertArgs} args - Arguments to update or create a CursosActivos.
     * @example
     * // Update or create a CursosActivos
     * const cursosActivos = await prisma.cursosActivos.upsert({
     *   create: {
     *     // ... data to create a CursosActivos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CursosActivos we want to update
     *   }
     * })
    **/
    upsert<T extends CursosActivosUpsertArgs>(
      args: SelectSubset<T, CursosActivosUpsertArgs>
    ): CheckSelect<T, Prisma__CursosActivosClient<CursosActivos>, Prisma__CursosActivosClient<CursosActivosGetPayload<T>>>

    /**
     * Count the number of CursosActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosActivosCountArgs} args - Arguments to filter CursosActivos to count.
     * @example
     * // Count the number of CursosActivos
     * const count = await prisma.cursosActivos.count({
     *   where: {
     *     // ... the filter for the CursosActivos we want to count
     *   }
     * })
    **/
    count<T extends CursosActivosCountArgs>(
      args?: Subset<T, CursosActivosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursosActivosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CursosActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosActivosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursosActivosAggregateArgs>(args: Subset<T, CursosActivosAggregateArgs>): PrismaPromise<GetCursosActivosAggregateType<T>>

    /**
     * Group by CursosActivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosActivosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursosActivosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursosActivosGroupByArgs['orderBy'] }
        : { orderBy?: CursosActivosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursosActivosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursosActivosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CursosActivos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CursosActivosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sala<T extends SalasArgs = {}>(args?: Subset<T, SalasArgs>): CheckSelect<T, Prisma__SalasClient<Salas | null >, Prisma__SalasClient<SalasGetPayload<T> | null >>;

    alumnos<T extends AlumnoOnCursoActivoFindManyArgs = {}>(args?: Subset<T, AlumnoOnCursoActivoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AlumnoOnCursoActivo>>, PrismaPromise<Array<AlumnoOnCursoActivoGetPayload<T>>>>;

    localidadCurso<T extends LocalidadOnCursoArgs = {}>(args?: Subset<T, LocalidadOnCursoArgs>): CheckSelect<T, Prisma__LocalidadOnCursoClient<LocalidadOnCurso | null >, Prisma__LocalidadOnCursoClient<LocalidadOnCursoGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CursosActivos findUnique
   */
  export type CursosActivosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
    /**
     * Throw an Error if a CursosActivos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CursosActivos to fetch.
     * 
    **/
    where: CursosActivosWhereUniqueInput
  }


  /**
   * CursosActivos findFirst
   */
  export type CursosActivosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
    /**
     * Throw an Error if a CursosActivos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CursosActivos to fetch.
     * 
    **/
    where?: CursosActivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursosActivos to fetch.
     * 
    **/
    orderBy?: Enumerable<CursosActivosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CursosActivos.
     * 
    **/
    cursor?: CursosActivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursosActivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursosActivos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CursosActivos.
     * 
    **/
    distinct?: Enumerable<CursosActivosScalarFieldEnum>
  }


  /**
   * CursosActivos findMany
   */
  export type CursosActivosFindManyArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
    /**
     * Filter, which CursosActivos to fetch.
     * 
    **/
    where?: CursosActivosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursosActivos to fetch.
     * 
    **/
    orderBy?: Enumerable<CursosActivosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CursosActivos.
     * 
    **/
    cursor?: CursosActivosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursosActivos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursosActivos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CursosActivosScalarFieldEnum>
  }


  /**
   * CursosActivos create
   */
  export type CursosActivosCreateArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
    /**
     * The data needed to create a CursosActivos.
     * 
    **/
    data: XOR<CursosActivosCreateInput, CursosActivosUncheckedCreateInput>
  }


  /**
   * CursosActivos createMany
   */
  export type CursosActivosCreateManyArgs = {
    data: Enumerable<CursosActivosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CursosActivos update
   */
  export type CursosActivosUpdateArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
    /**
     * The data needed to update a CursosActivos.
     * 
    **/
    data: XOR<CursosActivosUpdateInput, CursosActivosUncheckedUpdateInput>
    /**
     * Choose, which CursosActivos to update.
     * 
    **/
    where: CursosActivosWhereUniqueInput
  }


  /**
   * CursosActivos updateMany
   */
  export type CursosActivosUpdateManyArgs = {
    data: XOR<CursosActivosUpdateManyMutationInput, CursosActivosUncheckedUpdateManyInput>
    where?: CursosActivosWhereInput
  }


  /**
   * CursosActivos upsert
   */
  export type CursosActivosUpsertArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
    /**
     * The filter to search for the CursosActivos to update in case it exists.
     * 
    **/
    where: CursosActivosWhereUniqueInput
    /**
     * In case the CursosActivos found by the `where` argument doesn't exist, create a new CursosActivos with this data.
     * 
    **/
    create: XOR<CursosActivosCreateInput, CursosActivosUncheckedCreateInput>
    /**
     * In case the CursosActivos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CursosActivosUpdateInput, CursosActivosUncheckedUpdateInput>
  }


  /**
   * CursosActivos delete
   */
  export type CursosActivosDeleteArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
    /**
     * Filter which CursosActivos to delete.
     * 
    **/
    where: CursosActivosWhereUniqueInput
  }


  /**
   * CursosActivos deleteMany
   */
  export type CursosActivosDeleteManyArgs = {
    where?: CursosActivosWhereInput
  }


  /**
   * CursosActivos without action
   */
  export type CursosActivosArgs = {
    /**
     * Select specific fields to fetch from the CursosActivos
     * 
    **/
    select?: CursosActivosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursosActivosInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const LocalidadScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type LocalidadScalarFieldEnum = (typeof LocalidadScalarFieldEnum)[keyof typeof LocalidadScalarFieldEnum]


  export const TipoCursoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type TipoCursoScalarFieldEnum = (typeof TipoCursoScalarFieldEnum)[keyof typeof TipoCursoScalarFieldEnum]


  export const CursoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    tipoCursoId: 'tipoCursoId'
  };

  export type CursoScalarFieldEnum = (typeof CursoScalarFieldEnum)[keyof typeof CursoScalarFieldEnum]


  export const LocalidadOnCursoScalarFieldEnum: {
    cursoId: 'cursoId',
    localidadId: 'localidadId',
    nombreMostrar: 'nombreMostrar',
    descripcion: 'descripcion'
  };

  export type LocalidadOnCursoScalarFieldEnum = (typeof LocalidadOnCursoScalarFieldEnum)[keyof typeof LocalidadOnCursoScalarFieldEnum]


  export const DestinatarioOnCursoScalarFieldEnum: {
    cursoId: 'cursoId',
    destinatarioId: 'destinatarioId',
    descripcion: 'descripcion',
    nombreMostrar: 'nombreMostrar'
  };

  export type DestinatarioOnCursoScalarFieldEnum = (typeof DestinatarioOnCursoScalarFieldEnum)[keyof typeof DestinatarioOnCursoScalarFieldEnum]


  export const AlumnoOnCursoActivoScalarFieldEnum: {
    cursoActivoId: 'cursoActivoId',
    alumnoId: 'alumnoId',
    descripcion: 'descripcion',
    nombreMostrar: 'nombreMostrar'
  };

  export type AlumnoOnCursoActivoScalarFieldEnum = (typeof AlumnoOnCursoActivoScalarFieldEnum)[keyof typeof AlumnoOnCursoActivoScalarFieldEnum]


  export const AlumnoScalarFieldEnum: {
    id: 'id',
    nroDocumento: 'nroDocumento',
    apellido: 'apellido',
    nombre: 'nombre',
    fechaNacimiento: 'fechaNacimiento',
    email: 'email',
    celular: 'celular',
    domicilio: 'domicilio',
    barrio: 'barrio',
    localidadId: 'localidadId'
  };

  export type AlumnoScalarFieldEnum = (typeof AlumnoScalarFieldEnum)[keyof typeof AlumnoScalarFieldEnum]


  export const DestinatariosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type DestinatariosScalarFieldEnum = (typeof DestinatariosScalarFieldEnum)[keyof typeof DestinatariosScalarFieldEnum]


  export const SalasScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    localidadId: 'localidadId'
  };

  export type SalasScalarFieldEnum = (typeof SalasScalarFieldEnum)[keyof typeof SalasScalarFieldEnum]


  export const CursosActivosScalarFieldEnum: {
    id: 'id',
    nombreMostrar: 'nombreMostrar',
    activo: 'activo',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    horario: 'horario',
    cupos: 'cupos',
    descripcion: 'descripcion',
    salaId: 'salaId',
    localidadId: 'localidadId',
    cursoId: 'cursoId'
  };

  export type CursosActivosScalarFieldEnum = (typeof CursosActivosScalarFieldEnum)[keyof typeof CursosActivosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type LocalidadWhereInput = {
    AND?: Enumerable<LocalidadWhereInput>
    OR?: Enumerable<LocalidadWhereInput>
    NOT?: Enumerable<LocalidadWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    alumnos?: AlumnoListRelationFilter
    salas?: SalasListRelationFilter
    cursos?: LocalidadOnCursoListRelationFilter
  }

  export type LocalidadOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type LocalidadWhereUniqueInput = {
    id?: number
  }

  export type LocalidadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LocalidadScalarWhereWithAggregatesInput>
    OR?: Enumerable<LocalidadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LocalidadScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
  }

  export type TipoCursoWhereInput = {
    AND?: Enumerable<TipoCursoWhereInput>
    OR?: Enumerable<TipoCursoWhereInput>
    NOT?: Enumerable<TipoCursoWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    curso?: XOR<CursoRelationFilter, CursoWhereInput> | null
  }

  export type TipoCursoOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type TipoCursoWhereUniqueInput = {
    id?: number
  }

  export type TipoCursoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TipoCursoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TipoCursoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TipoCursoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
  }

  export type CursoWhereInput = {
    AND?: Enumerable<CursoWhereInput>
    OR?: Enumerable<CursoWhereInput>
    NOT?: Enumerable<CursoWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    destinatatios?: DestinatarioOnCursoListRelationFilter
    localidad?: LocalidadOnCursoListRelationFilter
    tipocurso?: XOR<TipoCursoRelationFilter, TipoCursoWhereInput> | null
    tipoCursoId?: IntFilter | number
  }

  export type CursoOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipoCursoId?: SortOrder
  }

  export type CursoWhereUniqueInput = {
    id?: number
  }

  export type CursoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CursoScalarWhereWithAggregatesInput>
    OR?: Enumerable<CursoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CursoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
    tipoCursoId?: IntWithAggregatesFilter | number
  }

  export type LocalidadOnCursoWhereInput = {
    AND?: Enumerable<LocalidadOnCursoWhereInput>
    OR?: Enumerable<LocalidadOnCursoWhereInput>
    NOT?: Enumerable<LocalidadOnCursoWhereInput>
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    cursoId?: IntFilter | number
    localidad?: XOR<LocalidadRelationFilter, LocalidadWhereInput>
    localidadId?: IntFilter | number
    nombreMostrar?: StringFilter | string
    descripcion?: StringFilter | string
    cursosActivos?: CursosActivosListRelationFilter
  }

  export type LocalidadOnCursoOrderByInput = {
    cursoId?: SortOrder
    localidadId?: SortOrder
    nombreMostrar?: SortOrder
    descripcion?: SortOrder
  }

  export type LocalidadOnCursoWhereUniqueInput = {
    cursoId_localidadId?: LocalidadOnCursoCursoIdLocalidadIdCompoundUniqueInput
  }

  export type LocalidadOnCursoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LocalidadOnCursoScalarWhereWithAggregatesInput>
    OR?: Enumerable<LocalidadOnCursoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LocalidadOnCursoScalarWhereWithAggregatesInput>
    cursoId?: IntWithAggregatesFilter | number
    localidadId?: IntWithAggregatesFilter | number
    nombreMostrar?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
  }

  export type DestinatarioOnCursoWhereInput = {
    AND?: Enumerable<DestinatarioOnCursoWhereInput>
    OR?: Enumerable<DestinatarioOnCursoWhereInput>
    NOT?: Enumerable<DestinatarioOnCursoWhereInput>
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    cursoId?: IntFilter | number
    destinatario?: XOR<DestinatariosRelationFilter, DestinatariosWhereInput>
    destinatarioId?: IntFilter | number
    descripcion?: StringFilter | string
    nombreMostrar?: StringFilter | string
  }

  export type DestinatarioOnCursoOrderByInput = {
    cursoId?: SortOrder
    destinatarioId?: SortOrder
    descripcion?: SortOrder
    nombreMostrar?: SortOrder
  }

  export type DestinatarioOnCursoWhereUniqueInput = {
    cursoId_destinatarioId?: DestinatarioOnCursoCursoIdDestinatarioIdCompoundUniqueInput
  }

  export type DestinatarioOnCursoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DestinatarioOnCursoScalarWhereWithAggregatesInput>
    OR?: Enumerable<DestinatarioOnCursoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DestinatarioOnCursoScalarWhereWithAggregatesInput>
    cursoId?: IntWithAggregatesFilter | number
    destinatarioId?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    nombreMostrar?: StringWithAggregatesFilter | string
  }

  export type AlumnoOnCursoActivoWhereInput = {
    AND?: Enumerable<AlumnoOnCursoActivoWhereInput>
    OR?: Enumerable<AlumnoOnCursoActivoWhereInput>
    NOT?: Enumerable<AlumnoOnCursoActivoWhereInput>
    cursoActivo?: XOR<CursosActivosRelationFilter, CursosActivosWhereInput>
    cursoActivoId?: IntFilter | number
    alumno?: XOR<AlumnoRelationFilter, AlumnoWhereInput>
    alumnoId?: IntFilter | number
    descripcion?: StringFilter | string
    nombreMostrar?: StringFilter | string
  }

  export type AlumnoOnCursoActivoOrderByInput = {
    cursoActivoId?: SortOrder
    alumnoId?: SortOrder
    descripcion?: SortOrder
    nombreMostrar?: SortOrder
  }

  export type AlumnoOnCursoActivoWhereUniqueInput = {
    cursoActivoId_alumnoId?: AlumnoOnCursoActivoCursoActivoIdAlumnoIdCompoundUniqueInput
  }

  export type AlumnoOnCursoActivoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlumnoOnCursoActivoScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlumnoOnCursoActivoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlumnoOnCursoActivoScalarWhereWithAggregatesInput>
    cursoActivoId?: IntWithAggregatesFilter | number
    alumnoId?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    nombreMostrar?: StringWithAggregatesFilter | string
  }

  export type AlumnoWhereInput = {
    AND?: Enumerable<AlumnoWhereInput>
    OR?: Enumerable<AlumnoWhereInput>
    NOT?: Enumerable<AlumnoWhereInput>
    id?: IntFilter | number
    nroDocumento?: IntFilter | number
    apellido?: StringFilter | string
    nombre?: StringFilter | string
    fechaNacimiento?: DateTimeFilter | Date | string
    email?: StringFilter | string
    celular?: IntFilter | number
    domicilio?: StringFilter | string
    barrio?: StringNullableFilter | string | null
    localidad?: XOR<LocalidadRelationFilter, LocalidadWhereInput>
    localidadId?: IntFilter | number
    cursoActivo?: AlumnoOnCursoActivoListRelationFilter
  }

  export type AlumnoOrderByInput = {
    id?: SortOrder
    nroDocumento?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    fechaNacimiento?: SortOrder
    email?: SortOrder
    celular?: SortOrder
    domicilio?: SortOrder
    barrio?: SortOrder
    localidadId?: SortOrder
  }

  export type AlumnoWhereUniqueInput = {
    id?: number
    nroDocumento?: number
  }

  export type AlumnoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlumnoScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlumnoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlumnoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nroDocumento?: IntWithAggregatesFilter | number
    apellido?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    fechaNacimiento?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    celular?: IntWithAggregatesFilter | number
    domicilio?: StringWithAggregatesFilter | string
    barrio?: StringNullableWithAggregatesFilter | string | null
    localidadId?: IntWithAggregatesFilter | number
  }

  export type DestinatariosWhereInput = {
    AND?: Enumerable<DestinatariosWhereInput>
    OR?: Enumerable<DestinatariosWhereInput>
    NOT?: Enumerable<DestinatariosWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    cursos?: DestinatarioOnCursoListRelationFilter
  }

  export type DestinatariosOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type DestinatariosWhereUniqueInput = {
    id?: number
  }

  export type DestinatariosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DestinatariosScalarWhereWithAggregatesInput>
    OR?: Enumerable<DestinatariosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DestinatariosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
  }

  export type SalasWhereInput = {
    AND?: Enumerable<SalasWhereInput>
    OR?: Enumerable<SalasWhereInput>
    NOT?: Enumerable<SalasWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    localidad?: XOR<LocalidadRelationFilter, LocalidadWhereInput>
    localidadId?: IntFilter | number
    cursosActivos?: XOR<CursosActivosRelationFilter, CursosActivosWhereInput> | null
  }

  export type SalasOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    localidadId?: SortOrder
  }

  export type SalasWhereUniqueInput = {
    id?: number
  }

  export type SalasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SalasScalarWhereWithAggregatesInput>
    OR?: Enumerable<SalasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SalasScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    descripcion?: StringWithAggregatesFilter | string
    localidadId?: IntWithAggregatesFilter | number
  }

  export type CursosActivosWhereInput = {
    AND?: Enumerable<CursosActivosWhereInput>
    OR?: Enumerable<CursosActivosWhereInput>
    NOT?: Enumerable<CursosActivosWhereInput>
    id?: IntFilter | number
    nombreMostrar?: StringFilter | string
    activo?: BoolFilter | boolean
    fechaInicio?: DateTimeFilter | Date | string
    fechaFin?: DateTimeFilter | Date | string
    horario?: StringFilter | string
    cupos?: IntFilter | number
    descripcion?: StringFilter | string
    sala?: XOR<SalasRelationFilter, SalasWhereInput> | null
    salaId?: IntNullableFilter | number | null
    alumnos?: AlumnoOnCursoActivoListRelationFilter
    localidadCurso?: XOR<LocalidadOnCursoRelationFilter, LocalidadOnCursoWhereInput> | null
    localidadId?: IntNullableFilter | number | null
    cursoId?: IntNullableFilter | number | null
  }

  export type CursosActivosOrderByInput = {
    id?: SortOrder
    nombreMostrar?: SortOrder
    activo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    horario?: SortOrder
    cupos?: SortOrder
    descripcion?: SortOrder
    salaId?: SortOrder
    localidadId?: SortOrder
    cursoId?: SortOrder
  }

  export type CursosActivosWhereUniqueInput = {
    id?: number
  }

  export type CursosActivosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CursosActivosScalarWhereWithAggregatesInput>
    OR?: Enumerable<CursosActivosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CursosActivosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombreMostrar?: StringWithAggregatesFilter | string
    activo?: BoolWithAggregatesFilter | boolean
    fechaInicio?: DateTimeWithAggregatesFilter | Date | string
    fechaFin?: DateTimeWithAggregatesFilter | Date | string
    horario?: StringWithAggregatesFilter | string
    cupos?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    salaId?: IntNullableWithAggregatesFilter | number | null
    localidadId?: IntNullableWithAggregatesFilter | number | null
    cursoId?: IntNullableWithAggregatesFilter | number | null
  }

  export type LocalidadCreateInput = {
    nombre: string
    alumnos?: AlumnoCreateNestedManyWithoutLocalidadInput
    salas?: SalasCreateNestedManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedCreateInput = {
    id?: number
    nombre: string
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutLocalidadInput
    salas?: SalasUncheckedCreateNestedManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUncheckedCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    alumnos?: AlumnoUpdateManyWithoutLocalidadInput
    salas?: SalasUpdateManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUpdateManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    alumnos?: AlumnoUncheckedUpdateManyWithoutLocalidadInput
    salas?: SalasUncheckedUpdateManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUncheckedUpdateManyWithoutLocalidadInput
  }

  export type LocalidadCreateManyInput = {
    id?: number
    nombre: string
  }

  export type LocalidadUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type LocalidadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TipoCursoCreateInput = {
    nombre: string
    descripcion: string
    curso?: CursoCreateNestedOneWithoutTipocursoInput
  }

  export type TipoCursoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    curso?: CursoUncheckedCreateNestedOneWithoutTipocursoInput
  }

  export type TipoCursoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    curso?: CursoUpdateOneWithoutTipocursoInput
  }

  export type TipoCursoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    curso?: CursoUncheckedUpdateOneWithoutTipocursoInput
  }

  export type TipoCursoCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
  }

  export type TipoCursoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoCursoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type CursoCreateInput = {
    nombre: string
    descripcion: string
    destinatatios?: DestinatarioOnCursoCreateNestedManyWithoutCursoInput
    localidad?: LocalidadOnCursoCreateNestedManyWithoutCursoInput
    tipocurso?: TipoCursoCreateNestedOneWithoutCursoInput
  }

  export type CursoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    tipoCursoId: number
    destinatatios?: DestinatarioOnCursoUncheckedCreateNestedManyWithoutCursoInput
    localidad?: LocalidadOnCursoUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    destinatatios?: DestinatarioOnCursoUpdateManyWithoutCursoInput
    localidad?: LocalidadOnCursoUpdateManyWithoutCursoInput
    tipocurso?: TipoCursoUpdateOneWithoutCursoInput
  }

  export type CursoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipoCursoId?: IntFieldUpdateOperationsInput | number
    destinatatios?: DestinatarioOnCursoUncheckedUpdateManyWithoutCursoInput
    localidad?: LocalidadOnCursoUncheckedUpdateManyWithoutCursoInput
  }

  export type CursoCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
    tipoCursoId: number
  }

  export type CursoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type CursoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipoCursoId?: IntFieldUpdateOperationsInput | number
  }

  export type LocalidadOnCursoCreateInput = {
    nombreMostrar: string
    descripcion: string
    curso: CursoCreateNestedOneWithoutLocalidadInput
    localidad: LocalidadCreateNestedOneWithoutCursosInput
    cursosActivos?: CursosActivosCreateNestedManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUncheckedCreateInput = {
    cursoId: number
    localidadId: number
    nombreMostrar: string
    descripcion: string
    cursosActivos?: CursosActivosUncheckedCreateNestedManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUpdateInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    curso?: CursoUpdateOneRequiredWithoutLocalidadInput
    localidad?: LocalidadUpdateOneRequiredWithoutCursosInput
    cursosActivos?: CursosActivosUpdateManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUncheckedUpdateInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    localidadId?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    cursosActivos?: CursosActivosUncheckedUpdateManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoCreateManyInput = {
    cursoId: number
    localidadId: number
    nombreMostrar: string
    descripcion: string
  }

  export type LocalidadOnCursoUpdateManyMutationInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type LocalidadOnCursoUncheckedUpdateManyInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    localidadId?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatarioOnCursoCreateInput = {
    descripcion: string
    nombreMostrar: string
    curso: CursoCreateNestedOneWithoutDestinatatiosInput
    destinatario: DestinatariosCreateNestedOneWithoutCursosInput
  }

  export type DestinatarioOnCursoUncheckedCreateInput = {
    cursoId: number
    destinatarioId: number
    descripcion: string
    nombreMostrar: string
  }

  export type DestinatarioOnCursoUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    curso?: CursoUpdateOneRequiredWithoutDestinatatiosInput
    destinatario?: DestinatariosUpdateOneRequiredWithoutCursosInput
  }

  export type DestinatarioOnCursoUncheckedUpdateInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    destinatarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatarioOnCursoCreateManyInput = {
    cursoId: number
    destinatarioId: number
    descripcion: string
    nombreMostrar: string
  }

  export type DestinatarioOnCursoUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatarioOnCursoUncheckedUpdateManyInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    destinatarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type AlumnoOnCursoActivoCreateInput = {
    descripcion: string
    nombreMostrar: string
    cursoActivo: CursosActivosCreateNestedOneWithoutAlumnosInput
    alumno: AlumnoCreateNestedOneWithoutCursoActivoInput
  }

  export type AlumnoOnCursoActivoUncheckedCreateInput = {
    cursoActivoId: number
    alumnoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type AlumnoOnCursoActivoUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    cursoActivo?: CursosActivosUpdateOneRequiredWithoutAlumnosInput
    alumno?: AlumnoUpdateOneRequiredWithoutCursoActivoInput
  }

  export type AlumnoOnCursoActivoUncheckedUpdateInput = {
    cursoActivoId?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type AlumnoOnCursoActivoCreateManyInput = {
    cursoActivoId: number
    alumnoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type AlumnoOnCursoActivoUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type AlumnoOnCursoActivoUncheckedUpdateManyInput = {
    cursoActivoId?: IntFieldUpdateOperationsInput | number
    alumnoId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type AlumnoCreateInput = {
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
    localidad: LocalidadCreateNestedOneWithoutAlumnosInput
    cursoActivo?: AlumnoOnCursoActivoCreateNestedManyWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateInput = {
    id?: number
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
    localidadId: number
    cursoActivo?: AlumnoOnCursoActivoUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type AlumnoUpdateInput = {
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: LocalidadUpdateOneRequiredWithoutAlumnosInput
    cursoActivo?: AlumnoOnCursoActivoUpdateManyWithoutAlumnoInput
  }

  export type AlumnoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidadId?: IntFieldUpdateOperationsInput | number
    cursoActivo?: AlumnoOnCursoActivoUncheckedUpdateManyWithoutAlumnoInput
  }

  export type AlumnoCreateManyInput = {
    id?: number
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
    localidadId: number
  }

  export type AlumnoUpdateManyMutationInput = {
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlumnoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidadId?: IntFieldUpdateOperationsInput | number
  }

  export type DestinatariosCreateInput = {
    nombre: string
    cursos?: DestinatarioOnCursoCreateNestedManyWithoutDestinatarioInput
  }

  export type DestinatariosUncheckedCreateInput = {
    id?: number
    nombre: string
    cursos?: DestinatarioOnCursoUncheckedCreateNestedManyWithoutDestinatarioInput
  }

  export type DestinatariosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    cursos?: DestinatarioOnCursoUpdateManyWithoutDestinatarioInput
  }

  export type DestinatariosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    cursos?: DestinatarioOnCursoUncheckedUpdateManyWithoutDestinatarioInput
  }

  export type DestinatariosCreateManyInput = {
    id?: number
    nombre: string
  }

  export type DestinatariosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatariosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type SalasCreateInput = {
    nombre: string
    descripcion: string
    localidad: LocalidadCreateNestedOneWithoutSalasInput
    cursosActivos?: CursosActivosCreateNestedOneWithoutSalaInput
  }

  export type SalasUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    localidadId: number
    cursosActivos?: CursosActivosUncheckedCreateNestedOneWithoutSalaInput
  }

  export type SalasUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    localidad?: LocalidadUpdateOneRequiredWithoutSalasInput
    cursosActivos?: CursosActivosUpdateOneWithoutSalaInput
  }

  export type SalasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    localidadId?: IntFieldUpdateOperationsInput | number
    cursosActivos?: CursosActivosUncheckedUpdateOneWithoutSalaInput
  }

  export type SalasCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
    localidadId: number
  }

  export type SalasUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type SalasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    localidadId?: IntFieldUpdateOperationsInput | number
  }

  export type CursosActivosCreateInput = {
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    sala?: SalasCreateNestedOneWithoutCursosActivosInput
    alumnos?: AlumnoOnCursoActivoCreateNestedManyWithoutCursoActivoInput
    localidadCurso?: LocalidadOnCursoCreateNestedOneWithoutCursosActivosInput
  }

  export type CursosActivosUncheckedCreateInput = {
    id?: number
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    salaId?: number | null
    localidadId?: number | null
    cursoId?: number | null
    alumnos?: AlumnoOnCursoActivoUncheckedCreateNestedManyWithoutCursoActivoInput
  }

  export type CursosActivosUpdateInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sala?: SalasUpdateOneWithoutCursosActivosInput
    alumnos?: AlumnoOnCursoActivoUpdateManyWithoutCursoActivoInput
    localidadCurso?: LocalidadOnCursoUpdateOneWithoutCursosActivosInput
  }

  export type CursosActivosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    salaId?: NullableIntFieldUpdateOperationsInput | number | null
    localidadId?: NullableIntFieldUpdateOperationsInput | number | null
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnos?: AlumnoOnCursoActivoUncheckedUpdateManyWithoutCursoActivoInput
  }

  export type CursosActivosCreateManyInput = {
    id?: number
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    salaId?: number | null
    localidadId?: number | null
    cursoId?: number | null
  }

  export type CursosActivosUpdateManyMutationInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type CursosActivosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    salaId?: NullableIntFieldUpdateOperationsInput | number | null
    localidadId?: NullableIntFieldUpdateOperationsInput | number | null
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type AlumnoListRelationFilter = {
    every?: AlumnoWhereInput
    some?: AlumnoWhereInput
    none?: AlumnoWhereInput
  }

  export type SalasListRelationFilter = {
    every?: SalasWhereInput
    some?: SalasWhereInput
    none?: SalasWhereInput
  }

  export type LocalidadOnCursoListRelationFilter = {
    every?: LocalidadOnCursoWhereInput
    some?: LocalidadOnCursoWhereInput
    none?: LocalidadOnCursoWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type CursoRelationFilter = {
    is?: CursoWhereInput
    isNot?: CursoWhereInput
  }

  export type DestinatarioOnCursoListRelationFilter = {
    every?: DestinatarioOnCursoWhereInput
    some?: DestinatarioOnCursoWhereInput
    none?: DestinatarioOnCursoWhereInput
  }

  export type TipoCursoRelationFilter = {
    is?: TipoCursoWhereInput | null
    isNot?: TipoCursoWhereInput | null
  }

  export type LocalidadRelationFilter = {
    is?: LocalidadWhereInput
    isNot?: LocalidadWhereInput
  }

  export type CursosActivosListRelationFilter = {
    every?: CursosActivosWhereInput
    some?: CursosActivosWhereInput
    none?: CursosActivosWhereInput
  }

  export type LocalidadOnCursoCursoIdLocalidadIdCompoundUniqueInput = {
    cursoId: number
    localidadId: number
  }

  export type DestinatariosRelationFilter = {
    is?: DestinatariosWhereInput
    isNot?: DestinatariosWhereInput
  }

  export type DestinatarioOnCursoCursoIdDestinatarioIdCompoundUniqueInput = {
    cursoId: number
    destinatarioId: number
  }

  export type CursosActivosRelationFilter = {
    is?: CursosActivosWhereInput
    isNot?: CursosActivosWhereInput
  }

  export type AlumnoRelationFilter = {
    is?: AlumnoWhereInput
    isNot?: AlumnoWhereInput
  }

  export type AlumnoOnCursoActivoCursoActivoIdAlumnoIdCompoundUniqueInput = {
    cursoActivoId: number
    alumnoId: number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type AlumnoOnCursoActivoListRelationFilter = {
    every?: AlumnoOnCursoActivoWhereInput
    some?: AlumnoOnCursoActivoWhereInput
    none?: AlumnoOnCursoActivoWhereInput
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type SalasRelationFilter = {
    is?: SalasWhereInput | null
    isNot?: SalasWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type LocalidadOnCursoRelationFilter = {
    is?: LocalidadOnCursoWhereInput | null
    isNot?: LocalidadOnCursoWhereInput | null
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type AlumnoCreateNestedManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<AlumnoCreateWithoutLocalidadInput>, Enumerable<AlumnoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<AlumnoCreateOrConnectWithoutLocalidadInput>
    createMany?: AlumnoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<AlumnoWhereUniqueInput>
  }

  export type SalasCreateNestedManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<SalasCreateWithoutLocalidadInput>, Enumerable<SalasUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<SalasCreateOrConnectWithoutLocalidadInput>
    createMany?: SalasCreateManyLocalidadInputEnvelope
    connect?: Enumerable<SalasWhereUniqueInput>
  }

  export type LocalidadOnCursoCreateNestedManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutLocalidadInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutLocalidadInput>
    createMany?: LocalidadOnCursoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
  }

  export type AlumnoUncheckedCreateNestedManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<AlumnoCreateWithoutLocalidadInput>, Enumerable<AlumnoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<AlumnoCreateOrConnectWithoutLocalidadInput>
    createMany?: AlumnoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<AlumnoWhereUniqueInput>
  }

  export type SalasUncheckedCreateNestedManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<SalasCreateWithoutLocalidadInput>, Enumerable<SalasUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<SalasCreateOrConnectWithoutLocalidadInput>
    createMany?: SalasCreateManyLocalidadInputEnvelope
    connect?: Enumerable<SalasWhereUniqueInput>
  }

  export type LocalidadOnCursoUncheckedCreateNestedManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutLocalidadInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutLocalidadInput>
    createMany?: LocalidadOnCursoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AlumnoUpdateManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<AlumnoCreateWithoutLocalidadInput>, Enumerable<AlumnoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<AlumnoCreateOrConnectWithoutLocalidadInput>
    upsert?: Enumerable<AlumnoUpsertWithWhereUniqueWithoutLocalidadInput>
    createMany?: AlumnoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<AlumnoWhereUniqueInput>
    set?: Enumerable<AlumnoWhereUniqueInput>
    disconnect?: Enumerable<AlumnoWhereUniqueInput>
    delete?: Enumerable<AlumnoWhereUniqueInput>
    update?: Enumerable<AlumnoUpdateWithWhereUniqueWithoutLocalidadInput>
    updateMany?: Enumerable<AlumnoUpdateManyWithWhereWithoutLocalidadInput>
    deleteMany?: Enumerable<AlumnoScalarWhereInput>
  }

  export type SalasUpdateManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<SalasCreateWithoutLocalidadInput>, Enumerable<SalasUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<SalasCreateOrConnectWithoutLocalidadInput>
    upsert?: Enumerable<SalasUpsertWithWhereUniqueWithoutLocalidadInput>
    createMany?: SalasCreateManyLocalidadInputEnvelope
    connect?: Enumerable<SalasWhereUniqueInput>
    set?: Enumerable<SalasWhereUniqueInput>
    disconnect?: Enumerable<SalasWhereUniqueInput>
    delete?: Enumerable<SalasWhereUniqueInput>
    update?: Enumerable<SalasUpdateWithWhereUniqueWithoutLocalidadInput>
    updateMany?: Enumerable<SalasUpdateManyWithWhereWithoutLocalidadInput>
    deleteMany?: Enumerable<SalasScalarWhereInput>
  }

  export type LocalidadOnCursoUpdateManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutLocalidadInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutLocalidadInput>
    upsert?: Enumerable<LocalidadOnCursoUpsertWithWhereUniqueWithoutLocalidadInput>
    createMany?: LocalidadOnCursoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    set?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    disconnect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    delete?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    update?: Enumerable<LocalidadOnCursoUpdateWithWhereUniqueWithoutLocalidadInput>
    updateMany?: Enumerable<LocalidadOnCursoUpdateManyWithWhereWithoutLocalidadInput>
    deleteMany?: Enumerable<LocalidadOnCursoScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlumnoUncheckedUpdateManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<AlumnoCreateWithoutLocalidadInput>, Enumerable<AlumnoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<AlumnoCreateOrConnectWithoutLocalidadInput>
    upsert?: Enumerable<AlumnoUpsertWithWhereUniqueWithoutLocalidadInput>
    createMany?: AlumnoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<AlumnoWhereUniqueInput>
    set?: Enumerable<AlumnoWhereUniqueInput>
    disconnect?: Enumerable<AlumnoWhereUniqueInput>
    delete?: Enumerable<AlumnoWhereUniqueInput>
    update?: Enumerable<AlumnoUpdateWithWhereUniqueWithoutLocalidadInput>
    updateMany?: Enumerable<AlumnoUpdateManyWithWhereWithoutLocalidadInput>
    deleteMany?: Enumerable<AlumnoScalarWhereInput>
  }

  export type SalasUncheckedUpdateManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<SalasCreateWithoutLocalidadInput>, Enumerable<SalasUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<SalasCreateOrConnectWithoutLocalidadInput>
    upsert?: Enumerable<SalasUpsertWithWhereUniqueWithoutLocalidadInput>
    createMany?: SalasCreateManyLocalidadInputEnvelope
    connect?: Enumerable<SalasWhereUniqueInput>
    set?: Enumerable<SalasWhereUniqueInput>
    disconnect?: Enumerable<SalasWhereUniqueInput>
    delete?: Enumerable<SalasWhereUniqueInput>
    update?: Enumerable<SalasUpdateWithWhereUniqueWithoutLocalidadInput>
    updateMany?: Enumerable<SalasUpdateManyWithWhereWithoutLocalidadInput>
    deleteMany?: Enumerable<SalasScalarWhereInput>
  }

  export type LocalidadOnCursoUncheckedUpdateManyWithoutLocalidadInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutLocalidadInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutLocalidadInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutLocalidadInput>
    upsert?: Enumerable<LocalidadOnCursoUpsertWithWhereUniqueWithoutLocalidadInput>
    createMany?: LocalidadOnCursoCreateManyLocalidadInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    set?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    disconnect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    delete?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    update?: Enumerable<LocalidadOnCursoUpdateWithWhereUniqueWithoutLocalidadInput>
    updateMany?: Enumerable<LocalidadOnCursoUpdateManyWithWhereWithoutLocalidadInput>
    deleteMany?: Enumerable<LocalidadOnCursoScalarWhereInput>
  }

  export type CursoCreateNestedOneWithoutTipocursoInput = {
    create?: XOR<CursoCreateWithoutTipocursoInput, CursoUncheckedCreateWithoutTipocursoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutTipocursoInput
    connect?: CursoWhereUniqueInput
  }

  export type CursoUncheckedCreateNestedOneWithoutTipocursoInput = {
    create?: XOR<CursoCreateWithoutTipocursoInput, CursoUncheckedCreateWithoutTipocursoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutTipocursoInput
    connect?: CursoWhereUniqueInput
  }

  export type CursoUpdateOneWithoutTipocursoInput = {
    create?: XOR<CursoCreateWithoutTipocursoInput, CursoUncheckedCreateWithoutTipocursoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutTipocursoInput
    upsert?: CursoUpsertWithoutTipocursoInput
    connect?: CursoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CursoUpdateWithoutTipocursoInput, CursoUncheckedUpdateWithoutTipocursoInput>
  }

  export type CursoUncheckedUpdateOneWithoutTipocursoInput = {
    create?: XOR<CursoCreateWithoutTipocursoInput, CursoUncheckedCreateWithoutTipocursoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutTipocursoInput
    upsert?: CursoUpsertWithoutTipocursoInput
    connect?: CursoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CursoUpdateWithoutTipocursoInput, CursoUncheckedUpdateWithoutTipocursoInput>
  }

  export type DestinatarioOnCursoCreateNestedManyWithoutCursoInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutCursoInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutCursoInput>
    createMany?: DestinatarioOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
  }

  export type LocalidadOnCursoCreateNestedManyWithoutCursoInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutCursoInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutCursoInput>
    createMany?: LocalidadOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
  }

  export type TipoCursoCreateNestedOneWithoutCursoInput = {
    create?: XOR<TipoCursoCreateWithoutCursoInput, TipoCursoUncheckedCreateWithoutCursoInput>
    connectOrCreate?: TipoCursoCreateOrConnectWithoutCursoInput
    connect?: TipoCursoWhereUniqueInput
  }

  export type DestinatarioOnCursoUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutCursoInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutCursoInput>
    createMany?: DestinatarioOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
  }

  export type LocalidadOnCursoUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutCursoInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutCursoInput>
    createMany?: LocalidadOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
  }

  export type DestinatarioOnCursoUpdateManyWithoutCursoInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutCursoInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutCursoInput>
    upsert?: Enumerable<DestinatarioOnCursoUpsertWithWhereUniqueWithoutCursoInput>
    createMany?: DestinatarioOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    set?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    disconnect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    delete?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    update?: Enumerable<DestinatarioOnCursoUpdateWithWhereUniqueWithoutCursoInput>
    updateMany?: Enumerable<DestinatarioOnCursoUpdateManyWithWhereWithoutCursoInput>
    deleteMany?: Enumerable<DestinatarioOnCursoScalarWhereInput>
  }

  export type LocalidadOnCursoUpdateManyWithoutCursoInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutCursoInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutCursoInput>
    upsert?: Enumerable<LocalidadOnCursoUpsertWithWhereUniqueWithoutCursoInput>
    createMany?: LocalidadOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    set?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    disconnect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    delete?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    update?: Enumerable<LocalidadOnCursoUpdateWithWhereUniqueWithoutCursoInput>
    updateMany?: Enumerable<LocalidadOnCursoUpdateManyWithWhereWithoutCursoInput>
    deleteMany?: Enumerable<LocalidadOnCursoScalarWhereInput>
  }

  export type TipoCursoUpdateOneWithoutCursoInput = {
    create?: XOR<TipoCursoCreateWithoutCursoInput, TipoCursoUncheckedCreateWithoutCursoInput>
    connectOrCreate?: TipoCursoCreateOrConnectWithoutCursoInput
    upsert?: TipoCursoUpsertWithoutCursoInput
    connect?: TipoCursoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TipoCursoUpdateWithoutCursoInput, TipoCursoUncheckedUpdateWithoutCursoInput>
  }

  export type DestinatarioOnCursoUncheckedUpdateManyWithoutCursoInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutCursoInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutCursoInput>
    upsert?: Enumerable<DestinatarioOnCursoUpsertWithWhereUniqueWithoutCursoInput>
    createMany?: DestinatarioOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    set?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    disconnect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    delete?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    update?: Enumerable<DestinatarioOnCursoUpdateWithWhereUniqueWithoutCursoInput>
    updateMany?: Enumerable<DestinatarioOnCursoUpdateManyWithWhereWithoutCursoInput>
    deleteMany?: Enumerable<DestinatarioOnCursoScalarWhereInput>
  }

  export type LocalidadOnCursoUncheckedUpdateManyWithoutCursoInput = {
    create?: XOR<Enumerable<LocalidadOnCursoCreateWithoutCursoInput>, Enumerable<LocalidadOnCursoUncheckedCreateWithoutCursoInput>>
    connectOrCreate?: Enumerable<LocalidadOnCursoCreateOrConnectWithoutCursoInput>
    upsert?: Enumerable<LocalidadOnCursoUpsertWithWhereUniqueWithoutCursoInput>
    createMany?: LocalidadOnCursoCreateManyCursoInputEnvelope
    connect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    set?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    disconnect?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    delete?: Enumerable<LocalidadOnCursoWhereUniqueInput>
    update?: Enumerable<LocalidadOnCursoUpdateWithWhereUniqueWithoutCursoInput>
    updateMany?: Enumerable<LocalidadOnCursoUpdateManyWithWhereWithoutCursoInput>
    deleteMany?: Enumerable<LocalidadOnCursoScalarWhereInput>
  }

  export type CursoCreateNestedOneWithoutLocalidadInput = {
    create?: XOR<CursoCreateWithoutLocalidadInput, CursoUncheckedCreateWithoutLocalidadInput>
    connectOrCreate?: CursoCreateOrConnectWithoutLocalidadInput
    connect?: CursoWhereUniqueInput
  }

  export type LocalidadCreateNestedOneWithoutCursosInput = {
    create?: XOR<LocalidadCreateWithoutCursosInput, LocalidadUncheckedCreateWithoutCursosInput>
    connectOrCreate?: LocalidadCreateOrConnectWithoutCursosInput
    connect?: LocalidadWhereUniqueInput
  }

  export type CursosActivosCreateNestedManyWithoutLocalidadCursoInput = {
    create?: XOR<Enumerable<CursosActivosCreateWithoutLocalidadCursoInput>, Enumerable<CursosActivosUncheckedCreateWithoutLocalidadCursoInput>>
    connectOrCreate?: Enumerable<CursosActivosCreateOrConnectWithoutLocalidadCursoInput>
    createMany?: CursosActivosCreateManyLocalidadCursoInputEnvelope
    connect?: Enumerable<CursosActivosWhereUniqueInput>
  }

  export type CursosActivosUncheckedCreateNestedManyWithoutLocalidadCursoInput = {
    create?: XOR<Enumerable<CursosActivosCreateWithoutLocalidadCursoInput>, Enumerable<CursosActivosUncheckedCreateWithoutLocalidadCursoInput>>
    connectOrCreate?: Enumerable<CursosActivosCreateOrConnectWithoutLocalidadCursoInput>
    createMany?: CursosActivosCreateManyLocalidadCursoInputEnvelope
    connect?: Enumerable<CursosActivosWhereUniqueInput>
  }

  export type CursoUpdateOneRequiredWithoutLocalidadInput = {
    create?: XOR<CursoCreateWithoutLocalidadInput, CursoUncheckedCreateWithoutLocalidadInput>
    connectOrCreate?: CursoCreateOrConnectWithoutLocalidadInput
    upsert?: CursoUpsertWithoutLocalidadInput
    connect?: CursoWhereUniqueInput
    update?: XOR<CursoUpdateWithoutLocalidadInput, CursoUncheckedUpdateWithoutLocalidadInput>
  }

  export type LocalidadUpdateOneRequiredWithoutCursosInput = {
    create?: XOR<LocalidadCreateWithoutCursosInput, LocalidadUncheckedCreateWithoutCursosInput>
    connectOrCreate?: LocalidadCreateOrConnectWithoutCursosInput
    upsert?: LocalidadUpsertWithoutCursosInput
    connect?: LocalidadWhereUniqueInput
    update?: XOR<LocalidadUpdateWithoutCursosInput, LocalidadUncheckedUpdateWithoutCursosInput>
  }

  export type CursosActivosUpdateManyWithoutLocalidadCursoInput = {
    create?: XOR<Enumerable<CursosActivosCreateWithoutLocalidadCursoInput>, Enumerable<CursosActivosUncheckedCreateWithoutLocalidadCursoInput>>
    connectOrCreate?: Enumerable<CursosActivosCreateOrConnectWithoutLocalidadCursoInput>
    upsert?: Enumerable<CursosActivosUpsertWithWhereUniqueWithoutLocalidadCursoInput>
    createMany?: CursosActivosCreateManyLocalidadCursoInputEnvelope
    connect?: Enumerable<CursosActivosWhereUniqueInput>
    set?: Enumerable<CursosActivosWhereUniqueInput>
    disconnect?: Enumerable<CursosActivosWhereUniqueInput>
    delete?: Enumerable<CursosActivosWhereUniqueInput>
    update?: Enumerable<CursosActivosUpdateWithWhereUniqueWithoutLocalidadCursoInput>
    updateMany?: Enumerable<CursosActivosUpdateManyWithWhereWithoutLocalidadCursoInput>
    deleteMany?: Enumerable<CursosActivosScalarWhereInput>
  }

  export type CursosActivosUncheckedUpdateManyWithoutLocalidadCursoInput = {
    create?: XOR<Enumerable<CursosActivosCreateWithoutLocalidadCursoInput>, Enumerable<CursosActivosUncheckedCreateWithoutLocalidadCursoInput>>
    connectOrCreate?: Enumerable<CursosActivosCreateOrConnectWithoutLocalidadCursoInput>
    upsert?: Enumerable<CursosActivosUpsertWithWhereUniqueWithoutLocalidadCursoInput>
    createMany?: CursosActivosCreateManyLocalidadCursoInputEnvelope
    connect?: Enumerable<CursosActivosWhereUniqueInput>
    set?: Enumerable<CursosActivosWhereUniqueInput>
    disconnect?: Enumerable<CursosActivosWhereUniqueInput>
    delete?: Enumerable<CursosActivosWhereUniqueInput>
    update?: Enumerable<CursosActivosUpdateWithWhereUniqueWithoutLocalidadCursoInput>
    updateMany?: Enumerable<CursosActivosUpdateManyWithWhereWithoutLocalidadCursoInput>
    deleteMany?: Enumerable<CursosActivosScalarWhereInput>
  }

  export type CursoCreateNestedOneWithoutDestinatatiosInput = {
    create?: XOR<CursoCreateWithoutDestinatatiosInput, CursoUncheckedCreateWithoutDestinatatiosInput>
    connectOrCreate?: CursoCreateOrConnectWithoutDestinatatiosInput
    connect?: CursoWhereUniqueInput
  }

  export type DestinatariosCreateNestedOneWithoutCursosInput = {
    create?: XOR<DestinatariosCreateWithoutCursosInput, DestinatariosUncheckedCreateWithoutCursosInput>
    connectOrCreate?: DestinatariosCreateOrConnectWithoutCursosInput
    connect?: DestinatariosWhereUniqueInput
  }

  export type CursoUpdateOneRequiredWithoutDestinatatiosInput = {
    create?: XOR<CursoCreateWithoutDestinatatiosInput, CursoUncheckedCreateWithoutDestinatatiosInput>
    connectOrCreate?: CursoCreateOrConnectWithoutDestinatatiosInput
    upsert?: CursoUpsertWithoutDestinatatiosInput
    connect?: CursoWhereUniqueInput
    update?: XOR<CursoUpdateWithoutDestinatatiosInput, CursoUncheckedUpdateWithoutDestinatatiosInput>
  }

  export type DestinatariosUpdateOneRequiredWithoutCursosInput = {
    create?: XOR<DestinatariosCreateWithoutCursosInput, DestinatariosUncheckedCreateWithoutCursosInput>
    connectOrCreate?: DestinatariosCreateOrConnectWithoutCursosInput
    upsert?: DestinatariosUpsertWithoutCursosInput
    connect?: DestinatariosWhereUniqueInput
    update?: XOR<DestinatariosUpdateWithoutCursosInput, DestinatariosUncheckedUpdateWithoutCursosInput>
  }

  export type CursosActivosCreateNestedOneWithoutAlumnosInput = {
    create?: XOR<CursosActivosCreateWithoutAlumnosInput, CursosActivosUncheckedCreateWithoutAlumnosInput>
    connectOrCreate?: CursosActivosCreateOrConnectWithoutAlumnosInput
    connect?: CursosActivosWhereUniqueInput
  }

  export type AlumnoCreateNestedOneWithoutCursoActivoInput = {
    create?: XOR<AlumnoCreateWithoutCursoActivoInput, AlumnoUncheckedCreateWithoutCursoActivoInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutCursoActivoInput
    connect?: AlumnoWhereUniqueInput
  }

  export type CursosActivosUpdateOneRequiredWithoutAlumnosInput = {
    create?: XOR<CursosActivosCreateWithoutAlumnosInput, CursosActivosUncheckedCreateWithoutAlumnosInput>
    connectOrCreate?: CursosActivosCreateOrConnectWithoutAlumnosInput
    upsert?: CursosActivosUpsertWithoutAlumnosInput
    connect?: CursosActivosWhereUniqueInput
    update?: XOR<CursosActivosUpdateWithoutAlumnosInput, CursosActivosUncheckedUpdateWithoutAlumnosInput>
  }

  export type AlumnoUpdateOneRequiredWithoutCursoActivoInput = {
    create?: XOR<AlumnoCreateWithoutCursoActivoInput, AlumnoUncheckedCreateWithoutCursoActivoInput>
    connectOrCreate?: AlumnoCreateOrConnectWithoutCursoActivoInput
    upsert?: AlumnoUpsertWithoutCursoActivoInput
    connect?: AlumnoWhereUniqueInput
    update?: XOR<AlumnoUpdateWithoutCursoActivoInput, AlumnoUncheckedUpdateWithoutCursoActivoInput>
  }

  export type LocalidadCreateNestedOneWithoutAlumnosInput = {
    create?: XOR<LocalidadCreateWithoutAlumnosInput, LocalidadUncheckedCreateWithoutAlumnosInput>
    connectOrCreate?: LocalidadCreateOrConnectWithoutAlumnosInput
    connect?: LocalidadWhereUniqueInput
  }

  export type AlumnoOnCursoActivoCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutAlumnoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutAlumnoInput>
    createMany?: AlumnoOnCursoActivoCreateManyAlumnoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
  }

  export type AlumnoOnCursoActivoUncheckedCreateNestedManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutAlumnoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutAlumnoInput>
    createMany?: AlumnoOnCursoActivoCreateManyAlumnoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type LocalidadUpdateOneRequiredWithoutAlumnosInput = {
    create?: XOR<LocalidadCreateWithoutAlumnosInput, LocalidadUncheckedCreateWithoutAlumnosInput>
    connectOrCreate?: LocalidadCreateOrConnectWithoutAlumnosInput
    upsert?: LocalidadUpsertWithoutAlumnosInput
    connect?: LocalidadWhereUniqueInput
    update?: XOR<LocalidadUpdateWithoutAlumnosInput, LocalidadUncheckedUpdateWithoutAlumnosInput>
  }

  export type AlumnoOnCursoActivoUpdateManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutAlumnoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<AlumnoOnCursoActivoUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: AlumnoOnCursoActivoCreateManyAlumnoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    set?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    disconnect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    delete?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    update?: Enumerable<AlumnoOnCursoActivoUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<AlumnoOnCursoActivoUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<AlumnoOnCursoActivoScalarWhereInput>
  }

  export type AlumnoOnCursoActivoUncheckedUpdateManyWithoutAlumnoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutAlumnoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutAlumnoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutAlumnoInput>
    upsert?: Enumerable<AlumnoOnCursoActivoUpsertWithWhereUniqueWithoutAlumnoInput>
    createMany?: AlumnoOnCursoActivoCreateManyAlumnoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    set?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    disconnect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    delete?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    update?: Enumerable<AlumnoOnCursoActivoUpdateWithWhereUniqueWithoutAlumnoInput>
    updateMany?: Enumerable<AlumnoOnCursoActivoUpdateManyWithWhereWithoutAlumnoInput>
    deleteMany?: Enumerable<AlumnoOnCursoActivoScalarWhereInput>
  }

  export type DestinatarioOnCursoCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutDestinatarioInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutDestinatarioInput>
    createMany?: DestinatarioOnCursoCreateManyDestinatarioInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
  }

  export type DestinatarioOnCursoUncheckedCreateNestedManyWithoutDestinatarioInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutDestinatarioInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutDestinatarioInput>
    createMany?: DestinatarioOnCursoCreateManyDestinatarioInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
  }

  export type DestinatarioOnCursoUpdateManyWithoutDestinatarioInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutDestinatarioInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutDestinatarioInput>
    upsert?: Enumerable<DestinatarioOnCursoUpsertWithWhereUniqueWithoutDestinatarioInput>
    createMany?: DestinatarioOnCursoCreateManyDestinatarioInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    set?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    disconnect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    delete?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    update?: Enumerable<DestinatarioOnCursoUpdateWithWhereUniqueWithoutDestinatarioInput>
    updateMany?: Enumerable<DestinatarioOnCursoUpdateManyWithWhereWithoutDestinatarioInput>
    deleteMany?: Enumerable<DestinatarioOnCursoScalarWhereInput>
  }

  export type DestinatarioOnCursoUncheckedUpdateManyWithoutDestinatarioInput = {
    create?: XOR<Enumerable<DestinatarioOnCursoCreateWithoutDestinatarioInput>, Enumerable<DestinatarioOnCursoUncheckedCreateWithoutDestinatarioInput>>
    connectOrCreate?: Enumerable<DestinatarioOnCursoCreateOrConnectWithoutDestinatarioInput>
    upsert?: Enumerable<DestinatarioOnCursoUpsertWithWhereUniqueWithoutDestinatarioInput>
    createMany?: DestinatarioOnCursoCreateManyDestinatarioInputEnvelope
    connect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    set?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    disconnect?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    delete?: Enumerable<DestinatarioOnCursoWhereUniqueInput>
    update?: Enumerable<DestinatarioOnCursoUpdateWithWhereUniqueWithoutDestinatarioInput>
    updateMany?: Enumerable<DestinatarioOnCursoUpdateManyWithWhereWithoutDestinatarioInput>
    deleteMany?: Enumerable<DestinatarioOnCursoScalarWhereInput>
  }

  export type LocalidadCreateNestedOneWithoutSalasInput = {
    create?: XOR<LocalidadCreateWithoutSalasInput, LocalidadUncheckedCreateWithoutSalasInput>
    connectOrCreate?: LocalidadCreateOrConnectWithoutSalasInput
    connect?: LocalidadWhereUniqueInput
  }

  export type CursosActivosCreateNestedOneWithoutSalaInput = {
    create?: XOR<CursosActivosCreateWithoutSalaInput, CursosActivosUncheckedCreateWithoutSalaInput>
    connectOrCreate?: CursosActivosCreateOrConnectWithoutSalaInput
    connect?: CursosActivosWhereUniqueInput
  }

  export type CursosActivosUncheckedCreateNestedOneWithoutSalaInput = {
    create?: XOR<CursosActivosCreateWithoutSalaInput, CursosActivosUncheckedCreateWithoutSalaInput>
    connectOrCreate?: CursosActivosCreateOrConnectWithoutSalaInput
    connect?: CursosActivosWhereUniqueInput
  }

  export type LocalidadUpdateOneRequiredWithoutSalasInput = {
    create?: XOR<LocalidadCreateWithoutSalasInput, LocalidadUncheckedCreateWithoutSalasInput>
    connectOrCreate?: LocalidadCreateOrConnectWithoutSalasInput
    upsert?: LocalidadUpsertWithoutSalasInput
    connect?: LocalidadWhereUniqueInput
    update?: XOR<LocalidadUpdateWithoutSalasInput, LocalidadUncheckedUpdateWithoutSalasInput>
  }

  export type CursosActivosUpdateOneWithoutSalaInput = {
    create?: XOR<CursosActivosCreateWithoutSalaInput, CursosActivosUncheckedCreateWithoutSalaInput>
    connectOrCreate?: CursosActivosCreateOrConnectWithoutSalaInput
    upsert?: CursosActivosUpsertWithoutSalaInput
    connect?: CursosActivosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CursosActivosUpdateWithoutSalaInput, CursosActivosUncheckedUpdateWithoutSalaInput>
  }

  export type CursosActivosUncheckedUpdateOneWithoutSalaInput = {
    create?: XOR<CursosActivosCreateWithoutSalaInput, CursosActivosUncheckedCreateWithoutSalaInput>
    connectOrCreate?: CursosActivosCreateOrConnectWithoutSalaInput
    upsert?: CursosActivosUpsertWithoutSalaInput
    connect?: CursosActivosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CursosActivosUpdateWithoutSalaInput, CursosActivosUncheckedUpdateWithoutSalaInput>
  }

  export type SalasCreateNestedOneWithoutCursosActivosInput = {
    create?: XOR<SalasCreateWithoutCursosActivosInput, SalasUncheckedCreateWithoutCursosActivosInput>
    connectOrCreate?: SalasCreateOrConnectWithoutCursosActivosInput
    connect?: SalasWhereUniqueInput
  }

  export type AlumnoOnCursoActivoCreateNestedManyWithoutCursoActivoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutCursoActivoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutCursoActivoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutCursoActivoInput>
    createMany?: AlumnoOnCursoActivoCreateManyCursoActivoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
  }

  export type LocalidadOnCursoCreateNestedOneWithoutCursosActivosInput = {
    create?: XOR<LocalidadOnCursoCreateWithoutCursosActivosInput, LocalidadOnCursoUncheckedCreateWithoutCursosActivosInput>
    connectOrCreate?: LocalidadOnCursoCreateOrConnectWithoutCursosActivosInput
    connect?: LocalidadOnCursoWhereUniqueInput
  }

  export type AlumnoOnCursoActivoUncheckedCreateNestedManyWithoutCursoActivoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutCursoActivoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutCursoActivoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutCursoActivoInput>
    createMany?: AlumnoOnCursoActivoCreateManyCursoActivoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SalasUpdateOneWithoutCursosActivosInput = {
    create?: XOR<SalasCreateWithoutCursosActivosInput, SalasUncheckedCreateWithoutCursosActivosInput>
    connectOrCreate?: SalasCreateOrConnectWithoutCursosActivosInput
    upsert?: SalasUpsertWithoutCursosActivosInput
    connect?: SalasWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SalasUpdateWithoutCursosActivosInput, SalasUncheckedUpdateWithoutCursosActivosInput>
  }

  export type AlumnoOnCursoActivoUpdateManyWithoutCursoActivoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutCursoActivoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutCursoActivoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutCursoActivoInput>
    upsert?: Enumerable<AlumnoOnCursoActivoUpsertWithWhereUniqueWithoutCursoActivoInput>
    createMany?: AlumnoOnCursoActivoCreateManyCursoActivoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    set?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    disconnect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    delete?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    update?: Enumerable<AlumnoOnCursoActivoUpdateWithWhereUniqueWithoutCursoActivoInput>
    updateMany?: Enumerable<AlumnoOnCursoActivoUpdateManyWithWhereWithoutCursoActivoInput>
    deleteMany?: Enumerable<AlumnoOnCursoActivoScalarWhereInput>
  }

  export type LocalidadOnCursoUpdateOneWithoutCursosActivosInput = {
    create?: XOR<LocalidadOnCursoCreateWithoutCursosActivosInput, LocalidadOnCursoUncheckedCreateWithoutCursosActivosInput>
    connectOrCreate?: LocalidadOnCursoCreateOrConnectWithoutCursosActivosInput
    upsert?: LocalidadOnCursoUpsertWithoutCursosActivosInput
    connect?: LocalidadOnCursoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<LocalidadOnCursoUpdateWithoutCursosActivosInput, LocalidadOnCursoUncheckedUpdateWithoutCursosActivosInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlumnoOnCursoActivoUncheckedUpdateManyWithoutCursoActivoInput = {
    create?: XOR<Enumerable<AlumnoOnCursoActivoCreateWithoutCursoActivoInput>, Enumerable<AlumnoOnCursoActivoUncheckedCreateWithoutCursoActivoInput>>
    connectOrCreate?: Enumerable<AlumnoOnCursoActivoCreateOrConnectWithoutCursoActivoInput>
    upsert?: Enumerable<AlumnoOnCursoActivoUpsertWithWhereUniqueWithoutCursoActivoInput>
    createMany?: AlumnoOnCursoActivoCreateManyCursoActivoInputEnvelope
    connect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    set?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    disconnect?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    delete?: Enumerable<AlumnoOnCursoActivoWhereUniqueInput>
    update?: Enumerable<AlumnoOnCursoActivoUpdateWithWhereUniqueWithoutCursoActivoInput>
    updateMany?: Enumerable<AlumnoOnCursoActivoUpdateManyWithWhereWithoutCursoActivoInput>
    deleteMany?: Enumerable<AlumnoOnCursoActivoScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type AlumnoCreateWithoutLocalidadInput = {
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
    cursoActivo?: AlumnoOnCursoActivoCreateNestedManyWithoutAlumnoInput
  }

  export type AlumnoUncheckedCreateWithoutLocalidadInput = {
    id?: number
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
    cursoActivo?: AlumnoOnCursoActivoUncheckedCreateNestedManyWithoutAlumnoInput
  }

  export type AlumnoCreateOrConnectWithoutLocalidadInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutLocalidadInput, AlumnoUncheckedCreateWithoutLocalidadInput>
  }

  export type AlumnoCreateManyLocalidadInputEnvelope = {
    data: Enumerable<AlumnoCreateManyLocalidadInput>
    skipDuplicates?: boolean
  }

  export type SalasCreateWithoutLocalidadInput = {
    nombre: string
    descripcion: string
    cursosActivos?: CursosActivosCreateNestedOneWithoutSalaInput
  }

  export type SalasUncheckedCreateWithoutLocalidadInput = {
    id?: number
    nombre: string
    descripcion: string
    cursosActivos?: CursosActivosUncheckedCreateNestedOneWithoutSalaInput
  }

  export type SalasCreateOrConnectWithoutLocalidadInput = {
    where: SalasWhereUniqueInput
    create: XOR<SalasCreateWithoutLocalidadInput, SalasUncheckedCreateWithoutLocalidadInput>
  }

  export type SalasCreateManyLocalidadInputEnvelope = {
    data: Enumerable<SalasCreateManyLocalidadInput>
    skipDuplicates?: boolean
  }

  export type LocalidadOnCursoCreateWithoutLocalidadInput = {
    nombreMostrar: string
    descripcion: string
    curso: CursoCreateNestedOneWithoutLocalidadInput
    cursosActivos?: CursosActivosCreateNestedManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUncheckedCreateWithoutLocalidadInput = {
    cursoId: number
    nombreMostrar: string
    descripcion: string
    cursosActivos?: CursosActivosUncheckedCreateNestedManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoCreateOrConnectWithoutLocalidadInput = {
    where: LocalidadOnCursoWhereUniqueInput
    create: XOR<LocalidadOnCursoCreateWithoutLocalidadInput, LocalidadOnCursoUncheckedCreateWithoutLocalidadInput>
  }

  export type LocalidadOnCursoCreateManyLocalidadInputEnvelope = {
    data: Enumerable<LocalidadOnCursoCreateManyLocalidadInput>
    skipDuplicates?: boolean
  }

  export type AlumnoUpsertWithWhereUniqueWithoutLocalidadInput = {
    where: AlumnoWhereUniqueInput
    update: XOR<AlumnoUpdateWithoutLocalidadInput, AlumnoUncheckedUpdateWithoutLocalidadInput>
    create: XOR<AlumnoCreateWithoutLocalidadInput, AlumnoUncheckedCreateWithoutLocalidadInput>
  }

  export type AlumnoUpdateWithWhereUniqueWithoutLocalidadInput = {
    where: AlumnoWhereUniqueInput
    data: XOR<AlumnoUpdateWithoutLocalidadInput, AlumnoUncheckedUpdateWithoutLocalidadInput>
  }

  export type AlumnoUpdateManyWithWhereWithoutLocalidadInput = {
    where: AlumnoScalarWhereInput
    data: XOR<AlumnoUpdateManyMutationInput, AlumnoUncheckedUpdateManyWithoutAlumnosInput>
  }

  export type AlumnoScalarWhereInput = {
    AND?: Enumerable<AlumnoScalarWhereInput>
    OR?: Enumerable<AlumnoScalarWhereInput>
    NOT?: Enumerable<AlumnoScalarWhereInput>
    id?: IntFilter | number
    nroDocumento?: IntFilter | number
    apellido?: StringFilter | string
    nombre?: StringFilter | string
    fechaNacimiento?: DateTimeFilter | Date | string
    email?: StringFilter | string
    celular?: IntFilter | number
    domicilio?: StringFilter | string
    barrio?: StringNullableFilter | string | null
    localidadId?: IntFilter | number
  }

  export type SalasUpsertWithWhereUniqueWithoutLocalidadInput = {
    where: SalasWhereUniqueInput
    update: XOR<SalasUpdateWithoutLocalidadInput, SalasUncheckedUpdateWithoutLocalidadInput>
    create: XOR<SalasCreateWithoutLocalidadInput, SalasUncheckedCreateWithoutLocalidadInput>
  }

  export type SalasUpdateWithWhereUniqueWithoutLocalidadInput = {
    where: SalasWhereUniqueInput
    data: XOR<SalasUpdateWithoutLocalidadInput, SalasUncheckedUpdateWithoutLocalidadInput>
  }

  export type SalasUpdateManyWithWhereWithoutLocalidadInput = {
    where: SalasScalarWhereInput
    data: XOR<SalasUpdateManyMutationInput, SalasUncheckedUpdateManyWithoutSalasInput>
  }

  export type SalasScalarWhereInput = {
    AND?: Enumerable<SalasScalarWhereInput>
    OR?: Enumerable<SalasScalarWhereInput>
    NOT?: Enumerable<SalasScalarWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    descripcion?: StringFilter | string
    localidadId?: IntFilter | number
  }

  export type LocalidadOnCursoUpsertWithWhereUniqueWithoutLocalidadInput = {
    where: LocalidadOnCursoWhereUniqueInput
    update: XOR<LocalidadOnCursoUpdateWithoutLocalidadInput, LocalidadOnCursoUncheckedUpdateWithoutLocalidadInput>
    create: XOR<LocalidadOnCursoCreateWithoutLocalidadInput, LocalidadOnCursoUncheckedCreateWithoutLocalidadInput>
  }

  export type LocalidadOnCursoUpdateWithWhereUniqueWithoutLocalidadInput = {
    where: LocalidadOnCursoWhereUniqueInput
    data: XOR<LocalidadOnCursoUpdateWithoutLocalidadInput, LocalidadOnCursoUncheckedUpdateWithoutLocalidadInput>
  }

  export type LocalidadOnCursoUpdateManyWithWhereWithoutLocalidadInput = {
    where: LocalidadOnCursoScalarWhereInput
    data: XOR<LocalidadOnCursoUpdateManyMutationInput, LocalidadOnCursoUncheckedUpdateManyWithoutCursosInput>
  }

  export type LocalidadOnCursoScalarWhereInput = {
    AND?: Enumerable<LocalidadOnCursoScalarWhereInput>
    OR?: Enumerable<LocalidadOnCursoScalarWhereInput>
    NOT?: Enumerable<LocalidadOnCursoScalarWhereInput>
    cursoId?: IntFilter | number
    localidadId?: IntFilter | number
    nombreMostrar?: StringFilter | string
    descripcion?: StringFilter | string
  }

  export type CursoCreateWithoutTipocursoInput = {
    nombre: string
    descripcion: string
    destinatatios?: DestinatarioOnCursoCreateNestedManyWithoutCursoInput
    localidad?: LocalidadOnCursoCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutTipocursoInput = {
    id?: number
    nombre: string
    descripcion: string
    destinatatios?: DestinatarioOnCursoUncheckedCreateNestedManyWithoutCursoInput
    localidad?: LocalidadOnCursoUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutTipocursoInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutTipocursoInput, CursoUncheckedCreateWithoutTipocursoInput>
  }

  export type CursoUpsertWithoutTipocursoInput = {
    update: XOR<CursoUpdateWithoutTipocursoInput, CursoUncheckedUpdateWithoutTipocursoInput>
    create: XOR<CursoCreateWithoutTipocursoInput, CursoUncheckedCreateWithoutTipocursoInput>
  }

  export type CursoUpdateWithoutTipocursoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    destinatatios?: DestinatarioOnCursoUpdateManyWithoutCursoInput
    localidad?: LocalidadOnCursoUpdateManyWithoutCursoInput
  }

  export type CursoUncheckedUpdateWithoutTipocursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    destinatatios?: DestinatarioOnCursoUncheckedUpdateManyWithoutCursoInput
    localidad?: LocalidadOnCursoUncheckedUpdateManyWithoutCursoInput
  }

  export type DestinatarioOnCursoCreateWithoutCursoInput = {
    descripcion: string
    nombreMostrar: string
    destinatario: DestinatariosCreateNestedOneWithoutCursosInput
  }

  export type DestinatarioOnCursoUncheckedCreateWithoutCursoInput = {
    destinatarioId: number
    descripcion: string
    nombreMostrar: string
  }

  export type DestinatarioOnCursoCreateOrConnectWithoutCursoInput = {
    where: DestinatarioOnCursoWhereUniqueInput
    create: XOR<DestinatarioOnCursoCreateWithoutCursoInput, DestinatarioOnCursoUncheckedCreateWithoutCursoInput>
  }

  export type DestinatarioOnCursoCreateManyCursoInputEnvelope = {
    data: Enumerable<DestinatarioOnCursoCreateManyCursoInput>
    skipDuplicates?: boolean
  }

  export type LocalidadOnCursoCreateWithoutCursoInput = {
    nombreMostrar: string
    descripcion: string
    localidad: LocalidadCreateNestedOneWithoutCursosInput
    cursosActivos?: CursosActivosCreateNestedManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUncheckedCreateWithoutCursoInput = {
    localidadId: number
    nombreMostrar: string
    descripcion: string
    cursosActivos?: CursosActivosUncheckedCreateNestedManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoCreateOrConnectWithoutCursoInput = {
    where: LocalidadOnCursoWhereUniqueInput
    create: XOR<LocalidadOnCursoCreateWithoutCursoInput, LocalidadOnCursoUncheckedCreateWithoutCursoInput>
  }

  export type LocalidadOnCursoCreateManyCursoInputEnvelope = {
    data: Enumerable<LocalidadOnCursoCreateManyCursoInput>
    skipDuplicates?: boolean
  }

  export type TipoCursoCreateWithoutCursoInput = {
    nombre: string
    descripcion: string
  }

  export type TipoCursoUncheckedCreateWithoutCursoInput = {
    id?: number
    nombre: string
    descripcion: string
  }

  export type TipoCursoCreateOrConnectWithoutCursoInput = {
    where: TipoCursoWhereUniqueInput
    create: XOR<TipoCursoCreateWithoutCursoInput, TipoCursoUncheckedCreateWithoutCursoInput>
  }

  export type DestinatarioOnCursoUpsertWithWhereUniqueWithoutCursoInput = {
    where: DestinatarioOnCursoWhereUniqueInput
    update: XOR<DestinatarioOnCursoUpdateWithoutCursoInput, DestinatarioOnCursoUncheckedUpdateWithoutCursoInput>
    create: XOR<DestinatarioOnCursoCreateWithoutCursoInput, DestinatarioOnCursoUncheckedCreateWithoutCursoInput>
  }

  export type DestinatarioOnCursoUpdateWithWhereUniqueWithoutCursoInput = {
    where: DestinatarioOnCursoWhereUniqueInput
    data: XOR<DestinatarioOnCursoUpdateWithoutCursoInput, DestinatarioOnCursoUncheckedUpdateWithoutCursoInput>
  }

  export type DestinatarioOnCursoUpdateManyWithWhereWithoutCursoInput = {
    where: DestinatarioOnCursoScalarWhereInput
    data: XOR<DestinatarioOnCursoUpdateManyMutationInput, DestinatarioOnCursoUncheckedUpdateManyWithoutDestinatatiosInput>
  }

  export type DestinatarioOnCursoScalarWhereInput = {
    AND?: Enumerable<DestinatarioOnCursoScalarWhereInput>
    OR?: Enumerable<DestinatarioOnCursoScalarWhereInput>
    NOT?: Enumerable<DestinatarioOnCursoScalarWhereInput>
    cursoId?: IntFilter | number
    destinatarioId?: IntFilter | number
    descripcion?: StringFilter | string
    nombreMostrar?: StringFilter | string
  }

  export type LocalidadOnCursoUpsertWithWhereUniqueWithoutCursoInput = {
    where: LocalidadOnCursoWhereUniqueInput
    update: XOR<LocalidadOnCursoUpdateWithoutCursoInput, LocalidadOnCursoUncheckedUpdateWithoutCursoInput>
    create: XOR<LocalidadOnCursoCreateWithoutCursoInput, LocalidadOnCursoUncheckedCreateWithoutCursoInput>
  }

  export type LocalidadOnCursoUpdateWithWhereUniqueWithoutCursoInput = {
    where: LocalidadOnCursoWhereUniqueInput
    data: XOR<LocalidadOnCursoUpdateWithoutCursoInput, LocalidadOnCursoUncheckedUpdateWithoutCursoInput>
  }

  export type LocalidadOnCursoUpdateManyWithWhereWithoutCursoInput = {
    where: LocalidadOnCursoScalarWhereInput
    data: XOR<LocalidadOnCursoUpdateManyMutationInput, LocalidadOnCursoUncheckedUpdateManyWithoutLocalidadInput>
  }

  export type TipoCursoUpsertWithoutCursoInput = {
    update: XOR<TipoCursoUpdateWithoutCursoInput, TipoCursoUncheckedUpdateWithoutCursoInput>
    create: XOR<TipoCursoCreateWithoutCursoInput, TipoCursoUncheckedCreateWithoutCursoInput>
  }

  export type TipoCursoUpdateWithoutCursoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TipoCursoUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type CursoCreateWithoutLocalidadInput = {
    nombre: string
    descripcion: string
    destinatatios?: DestinatarioOnCursoCreateNestedManyWithoutCursoInput
    tipocurso?: TipoCursoCreateNestedOneWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutLocalidadInput = {
    id?: number
    nombre: string
    descripcion: string
    tipoCursoId: number
    destinatatios?: DestinatarioOnCursoUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutLocalidadInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutLocalidadInput, CursoUncheckedCreateWithoutLocalidadInput>
  }

  export type LocalidadCreateWithoutCursosInput = {
    nombre: string
    alumnos?: AlumnoCreateNestedManyWithoutLocalidadInput
    salas?: SalasCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedCreateWithoutCursosInput = {
    id?: number
    nombre: string
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutLocalidadInput
    salas?: SalasUncheckedCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadCreateOrConnectWithoutCursosInput = {
    where: LocalidadWhereUniqueInput
    create: XOR<LocalidadCreateWithoutCursosInput, LocalidadUncheckedCreateWithoutCursosInput>
  }

  export type CursosActivosCreateWithoutLocalidadCursoInput = {
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    sala?: SalasCreateNestedOneWithoutCursosActivosInput
    alumnos?: AlumnoOnCursoActivoCreateNestedManyWithoutCursoActivoInput
  }

  export type CursosActivosUncheckedCreateWithoutLocalidadCursoInput = {
    id?: number
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    salaId?: number | null
    alumnos?: AlumnoOnCursoActivoUncheckedCreateNestedManyWithoutCursoActivoInput
  }

  export type CursosActivosCreateOrConnectWithoutLocalidadCursoInput = {
    where: CursosActivosWhereUniqueInput
    create: XOR<CursosActivosCreateWithoutLocalidadCursoInput, CursosActivosUncheckedCreateWithoutLocalidadCursoInput>
  }

  export type CursosActivosCreateManyLocalidadCursoInputEnvelope = {
    data: Enumerable<CursosActivosCreateManyLocalidadCursoInput>
    skipDuplicates?: boolean
  }

  export type CursoUpsertWithoutLocalidadInput = {
    update: XOR<CursoUpdateWithoutLocalidadInput, CursoUncheckedUpdateWithoutLocalidadInput>
    create: XOR<CursoCreateWithoutLocalidadInput, CursoUncheckedCreateWithoutLocalidadInput>
  }

  export type CursoUpdateWithoutLocalidadInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    destinatatios?: DestinatarioOnCursoUpdateManyWithoutCursoInput
    tipocurso?: TipoCursoUpdateOneWithoutCursoInput
  }

  export type CursoUncheckedUpdateWithoutLocalidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipoCursoId?: IntFieldUpdateOperationsInput | number
    destinatatios?: DestinatarioOnCursoUncheckedUpdateManyWithoutCursoInput
  }

  export type LocalidadUpsertWithoutCursosInput = {
    update: XOR<LocalidadUpdateWithoutCursosInput, LocalidadUncheckedUpdateWithoutCursosInput>
    create: XOR<LocalidadCreateWithoutCursosInput, LocalidadUncheckedCreateWithoutCursosInput>
  }

  export type LocalidadUpdateWithoutCursosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    alumnos?: AlumnoUpdateManyWithoutLocalidadInput
    salas?: SalasUpdateManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedUpdateWithoutCursosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    alumnos?: AlumnoUncheckedUpdateManyWithoutLocalidadInput
    salas?: SalasUncheckedUpdateManyWithoutLocalidadInput
  }

  export type CursosActivosUpsertWithWhereUniqueWithoutLocalidadCursoInput = {
    where: CursosActivosWhereUniqueInput
    update: XOR<CursosActivosUpdateWithoutLocalidadCursoInput, CursosActivosUncheckedUpdateWithoutLocalidadCursoInput>
    create: XOR<CursosActivosCreateWithoutLocalidadCursoInput, CursosActivosUncheckedCreateWithoutLocalidadCursoInput>
  }

  export type CursosActivosUpdateWithWhereUniqueWithoutLocalidadCursoInput = {
    where: CursosActivosWhereUniqueInput
    data: XOR<CursosActivosUpdateWithoutLocalidadCursoInput, CursosActivosUncheckedUpdateWithoutLocalidadCursoInput>
  }

  export type CursosActivosUpdateManyWithWhereWithoutLocalidadCursoInput = {
    where: CursosActivosScalarWhereInput
    data: XOR<CursosActivosUpdateManyMutationInput, CursosActivosUncheckedUpdateManyWithoutCursosActivosInput>
  }

  export type CursosActivosScalarWhereInput = {
    AND?: Enumerable<CursosActivosScalarWhereInput>
    OR?: Enumerable<CursosActivosScalarWhereInput>
    NOT?: Enumerable<CursosActivosScalarWhereInput>
    id?: IntFilter | number
    nombreMostrar?: StringFilter | string
    activo?: BoolFilter | boolean
    fechaInicio?: DateTimeFilter | Date | string
    fechaFin?: DateTimeFilter | Date | string
    horario?: StringFilter | string
    cupos?: IntFilter | number
    descripcion?: StringFilter | string
    salaId?: IntNullableFilter | number | null
    localidadId?: IntNullableFilter | number | null
    cursoId?: IntNullableFilter | number | null
  }

  export type CursoCreateWithoutDestinatatiosInput = {
    nombre: string
    descripcion: string
    localidad?: LocalidadOnCursoCreateNestedManyWithoutCursoInput
    tipocurso?: TipoCursoCreateNestedOneWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutDestinatatiosInput = {
    id?: number
    nombre: string
    descripcion: string
    tipoCursoId: number
    localidad?: LocalidadOnCursoUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutDestinatatiosInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutDestinatatiosInput, CursoUncheckedCreateWithoutDestinatatiosInput>
  }

  export type DestinatariosCreateWithoutCursosInput = {
    nombre: string
  }

  export type DestinatariosUncheckedCreateWithoutCursosInput = {
    id?: number
    nombre: string
  }

  export type DestinatariosCreateOrConnectWithoutCursosInput = {
    where: DestinatariosWhereUniqueInput
    create: XOR<DestinatariosCreateWithoutCursosInput, DestinatariosUncheckedCreateWithoutCursosInput>
  }

  export type CursoUpsertWithoutDestinatatiosInput = {
    update: XOR<CursoUpdateWithoutDestinatatiosInput, CursoUncheckedUpdateWithoutDestinatatiosInput>
    create: XOR<CursoCreateWithoutDestinatatiosInput, CursoUncheckedCreateWithoutDestinatatiosInput>
  }

  export type CursoUpdateWithoutDestinatatiosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    localidad?: LocalidadOnCursoUpdateManyWithoutCursoInput
    tipocurso?: TipoCursoUpdateOneWithoutCursoInput
  }

  export type CursoUncheckedUpdateWithoutDestinatatiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    tipoCursoId?: IntFieldUpdateOperationsInput | number
    localidad?: LocalidadOnCursoUncheckedUpdateManyWithoutCursoInput
  }

  export type DestinatariosUpsertWithoutCursosInput = {
    update: XOR<DestinatariosUpdateWithoutCursosInput, DestinatariosUncheckedUpdateWithoutCursosInput>
    create: XOR<DestinatariosCreateWithoutCursosInput, DestinatariosUncheckedCreateWithoutCursosInput>
  }

  export type DestinatariosUpdateWithoutCursosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatariosUncheckedUpdateWithoutCursosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CursosActivosCreateWithoutAlumnosInput = {
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    sala?: SalasCreateNestedOneWithoutCursosActivosInput
    localidadCurso?: LocalidadOnCursoCreateNestedOneWithoutCursosActivosInput
  }

  export type CursosActivosUncheckedCreateWithoutAlumnosInput = {
    id?: number
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    salaId?: number | null
    localidadId?: number | null
    cursoId?: number | null
  }

  export type CursosActivosCreateOrConnectWithoutAlumnosInput = {
    where: CursosActivosWhereUniqueInput
    create: XOR<CursosActivosCreateWithoutAlumnosInput, CursosActivosUncheckedCreateWithoutAlumnosInput>
  }

  export type AlumnoCreateWithoutCursoActivoInput = {
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
    localidad: LocalidadCreateNestedOneWithoutAlumnosInput
  }

  export type AlumnoUncheckedCreateWithoutCursoActivoInput = {
    id?: number
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
    localidadId: number
  }

  export type AlumnoCreateOrConnectWithoutCursoActivoInput = {
    where: AlumnoWhereUniqueInput
    create: XOR<AlumnoCreateWithoutCursoActivoInput, AlumnoUncheckedCreateWithoutCursoActivoInput>
  }

  export type CursosActivosUpsertWithoutAlumnosInput = {
    update: XOR<CursosActivosUpdateWithoutAlumnosInput, CursosActivosUncheckedUpdateWithoutAlumnosInput>
    create: XOR<CursosActivosCreateWithoutAlumnosInput, CursosActivosUncheckedCreateWithoutAlumnosInput>
  }

  export type CursosActivosUpdateWithoutAlumnosInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sala?: SalasUpdateOneWithoutCursosActivosInput
    localidadCurso?: LocalidadOnCursoUpdateOneWithoutCursosActivosInput
  }

  export type CursosActivosUncheckedUpdateWithoutAlumnosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    salaId?: NullableIntFieldUpdateOperationsInput | number | null
    localidadId?: NullableIntFieldUpdateOperationsInput | number | null
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlumnoUpsertWithoutCursoActivoInput = {
    update: XOR<AlumnoUpdateWithoutCursoActivoInput, AlumnoUncheckedUpdateWithoutCursoActivoInput>
    create: XOR<AlumnoCreateWithoutCursoActivoInput, AlumnoUncheckedCreateWithoutCursoActivoInput>
  }

  export type AlumnoUpdateWithoutCursoActivoInput = {
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: LocalidadUpdateOneRequiredWithoutAlumnosInput
  }

  export type AlumnoUncheckedUpdateWithoutCursoActivoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidadId?: IntFieldUpdateOperationsInput | number
  }

  export type LocalidadCreateWithoutAlumnosInput = {
    nombre: string
    salas?: SalasCreateNestedManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedCreateWithoutAlumnosInput = {
    id?: number
    nombre: string
    salas?: SalasUncheckedCreateNestedManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUncheckedCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadCreateOrConnectWithoutAlumnosInput = {
    where: LocalidadWhereUniqueInput
    create: XOR<LocalidadCreateWithoutAlumnosInput, LocalidadUncheckedCreateWithoutAlumnosInput>
  }

  export type AlumnoOnCursoActivoCreateWithoutAlumnoInput = {
    descripcion: string
    nombreMostrar: string
    cursoActivo: CursosActivosCreateNestedOneWithoutAlumnosInput
  }

  export type AlumnoOnCursoActivoUncheckedCreateWithoutAlumnoInput = {
    cursoActivoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type AlumnoOnCursoActivoCreateOrConnectWithoutAlumnoInput = {
    where: AlumnoOnCursoActivoWhereUniqueInput
    create: XOR<AlumnoOnCursoActivoCreateWithoutAlumnoInput, AlumnoOnCursoActivoUncheckedCreateWithoutAlumnoInput>
  }

  export type AlumnoOnCursoActivoCreateManyAlumnoInputEnvelope = {
    data: Enumerable<AlumnoOnCursoActivoCreateManyAlumnoInput>
    skipDuplicates?: boolean
  }

  export type LocalidadUpsertWithoutAlumnosInput = {
    update: XOR<LocalidadUpdateWithoutAlumnosInput, LocalidadUncheckedUpdateWithoutAlumnosInput>
    create: XOR<LocalidadCreateWithoutAlumnosInput, LocalidadUncheckedCreateWithoutAlumnosInput>
  }

  export type LocalidadUpdateWithoutAlumnosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    salas?: SalasUpdateManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUpdateManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedUpdateWithoutAlumnosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    salas?: SalasUncheckedUpdateManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUncheckedUpdateManyWithoutLocalidadInput
  }

  export type AlumnoOnCursoActivoUpsertWithWhereUniqueWithoutAlumnoInput = {
    where: AlumnoOnCursoActivoWhereUniqueInput
    update: XOR<AlumnoOnCursoActivoUpdateWithoutAlumnoInput, AlumnoOnCursoActivoUncheckedUpdateWithoutAlumnoInput>
    create: XOR<AlumnoOnCursoActivoCreateWithoutAlumnoInput, AlumnoOnCursoActivoUncheckedCreateWithoutAlumnoInput>
  }

  export type AlumnoOnCursoActivoUpdateWithWhereUniqueWithoutAlumnoInput = {
    where: AlumnoOnCursoActivoWhereUniqueInput
    data: XOR<AlumnoOnCursoActivoUpdateWithoutAlumnoInput, AlumnoOnCursoActivoUncheckedUpdateWithoutAlumnoInput>
  }

  export type AlumnoOnCursoActivoUpdateManyWithWhereWithoutAlumnoInput = {
    where: AlumnoOnCursoActivoScalarWhereInput
    data: XOR<AlumnoOnCursoActivoUpdateManyMutationInput, AlumnoOnCursoActivoUncheckedUpdateManyWithoutCursoActivoInput>
  }

  export type AlumnoOnCursoActivoScalarWhereInput = {
    AND?: Enumerable<AlumnoOnCursoActivoScalarWhereInput>
    OR?: Enumerable<AlumnoOnCursoActivoScalarWhereInput>
    NOT?: Enumerable<AlumnoOnCursoActivoScalarWhereInput>
    cursoActivoId?: IntFilter | number
    alumnoId?: IntFilter | number
    descripcion?: StringFilter | string
    nombreMostrar?: StringFilter | string
  }

  export type DestinatarioOnCursoCreateWithoutDestinatarioInput = {
    descripcion: string
    nombreMostrar: string
    curso: CursoCreateNestedOneWithoutDestinatatiosInput
  }

  export type DestinatarioOnCursoUncheckedCreateWithoutDestinatarioInput = {
    cursoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type DestinatarioOnCursoCreateOrConnectWithoutDestinatarioInput = {
    where: DestinatarioOnCursoWhereUniqueInput
    create: XOR<DestinatarioOnCursoCreateWithoutDestinatarioInput, DestinatarioOnCursoUncheckedCreateWithoutDestinatarioInput>
  }

  export type DestinatarioOnCursoCreateManyDestinatarioInputEnvelope = {
    data: Enumerable<DestinatarioOnCursoCreateManyDestinatarioInput>
    skipDuplicates?: boolean
  }

  export type DestinatarioOnCursoUpsertWithWhereUniqueWithoutDestinatarioInput = {
    where: DestinatarioOnCursoWhereUniqueInput
    update: XOR<DestinatarioOnCursoUpdateWithoutDestinatarioInput, DestinatarioOnCursoUncheckedUpdateWithoutDestinatarioInput>
    create: XOR<DestinatarioOnCursoCreateWithoutDestinatarioInput, DestinatarioOnCursoUncheckedCreateWithoutDestinatarioInput>
  }

  export type DestinatarioOnCursoUpdateWithWhereUniqueWithoutDestinatarioInput = {
    where: DestinatarioOnCursoWhereUniqueInput
    data: XOR<DestinatarioOnCursoUpdateWithoutDestinatarioInput, DestinatarioOnCursoUncheckedUpdateWithoutDestinatarioInput>
  }

  export type DestinatarioOnCursoUpdateManyWithWhereWithoutDestinatarioInput = {
    where: DestinatarioOnCursoScalarWhereInput
    data: XOR<DestinatarioOnCursoUpdateManyMutationInput, DestinatarioOnCursoUncheckedUpdateManyWithoutCursosInput>
  }

  export type LocalidadCreateWithoutSalasInput = {
    nombre: string
    alumnos?: AlumnoCreateNestedManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedCreateWithoutSalasInput = {
    id?: number
    nombre: string
    alumnos?: AlumnoUncheckedCreateNestedManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUncheckedCreateNestedManyWithoutLocalidadInput
  }

  export type LocalidadCreateOrConnectWithoutSalasInput = {
    where: LocalidadWhereUniqueInput
    create: XOR<LocalidadCreateWithoutSalasInput, LocalidadUncheckedCreateWithoutSalasInput>
  }

  export type CursosActivosCreateWithoutSalaInput = {
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    alumnos?: AlumnoOnCursoActivoCreateNestedManyWithoutCursoActivoInput
    localidadCurso?: LocalidadOnCursoCreateNestedOneWithoutCursosActivosInput
  }

  export type CursosActivosUncheckedCreateWithoutSalaInput = {
    id?: number
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    localidadId?: number | null
    cursoId?: number | null
    alumnos?: AlumnoOnCursoActivoUncheckedCreateNestedManyWithoutCursoActivoInput
  }

  export type CursosActivosCreateOrConnectWithoutSalaInput = {
    where: CursosActivosWhereUniqueInput
    create: XOR<CursosActivosCreateWithoutSalaInput, CursosActivosUncheckedCreateWithoutSalaInput>
  }

  export type LocalidadUpsertWithoutSalasInput = {
    update: XOR<LocalidadUpdateWithoutSalasInput, LocalidadUncheckedUpdateWithoutSalasInput>
    create: XOR<LocalidadCreateWithoutSalasInput, LocalidadUncheckedCreateWithoutSalasInput>
  }

  export type LocalidadUpdateWithoutSalasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    alumnos?: AlumnoUpdateManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUpdateManyWithoutLocalidadInput
  }

  export type LocalidadUncheckedUpdateWithoutSalasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    alumnos?: AlumnoUncheckedUpdateManyWithoutLocalidadInput
    cursos?: LocalidadOnCursoUncheckedUpdateManyWithoutLocalidadInput
  }

  export type CursosActivosUpsertWithoutSalaInput = {
    update: XOR<CursosActivosUpdateWithoutSalaInput, CursosActivosUncheckedUpdateWithoutSalaInput>
    create: XOR<CursosActivosCreateWithoutSalaInput, CursosActivosUncheckedCreateWithoutSalaInput>
  }

  export type CursosActivosUpdateWithoutSalaInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    alumnos?: AlumnoOnCursoActivoUpdateManyWithoutCursoActivoInput
    localidadCurso?: LocalidadOnCursoUpdateOneWithoutCursosActivosInput
  }

  export type CursosActivosUncheckedUpdateWithoutSalaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    localidadId?: NullableIntFieldUpdateOperationsInput | number | null
    cursoId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnos?: AlumnoOnCursoActivoUncheckedUpdateManyWithoutCursoActivoInput
  }

  export type SalasCreateWithoutCursosActivosInput = {
    nombre: string
    descripcion: string
    localidad: LocalidadCreateNestedOneWithoutSalasInput
  }

  export type SalasUncheckedCreateWithoutCursosActivosInput = {
    id?: number
    nombre: string
    descripcion: string
    localidadId: number
  }

  export type SalasCreateOrConnectWithoutCursosActivosInput = {
    where: SalasWhereUniqueInput
    create: XOR<SalasCreateWithoutCursosActivosInput, SalasUncheckedCreateWithoutCursosActivosInput>
  }

  export type AlumnoOnCursoActivoCreateWithoutCursoActivoInput = {
    descripcion: string
    nombreMostrar: string
    alumno: AlumnoCreateNestedOneWithoutCursoActivoInput
  }

  export type AlumnoOnCursoActivoUncheckedCreateWithoutCursoActivoInput = {
    alumnoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type AlumnoOnCursoActivoCreateOrConnectWithoutCursoActivoInput = {
    where: AlumnoOnCursoActivoWhereUniqueInput
    create: XOR<AlumnoOnCursoActivoCreateWithoutCursoActivoInput, AlumnoOnCursoActivoUncheckedCreateWithoutCursoActivoInput>
  }

  export type AlumnoOnCursoActivoCreateManyCursoActivoInputEnvelope = {
    data: Enumerable<AlumnoOnCursoActivoCreateManyCursoActivoInput>
    skipDuplicates?: boolean
  }

  export type LocalidadOnCursoCreateWithoutCursosActivosInput = {
    nombreMostrar: string
    descripcion: string
    curso: CursoCreateNestedOneWithoutLocalidadInput
    localidad: LocalidadCreateNestedOneWithoutCursosInput
  }

  export type LocalidadOnCursoUncheckedCreateWithoutCursosActivosInput = {
    cursoId: number
    localidadId: number
    nombreMostrar: string
    descripcion: string
  }

  export type LocalidadOnCursoCreateOrConnectWithoutCursosActivosInput = {
    where: LocalidadOnCursoWhereUniqueInput
    create: XOR<LocalidadOnCursoCreateWithoutCursosActivosInput, LocalidadOnCursoUncheckedCreateWithoutCursosActivosInput>
  }

  export type SalasUpsertWithoutCursosActivosInput = {
    update: XOR<SalasUpdateWithoutCursosActivosInput, SalasUncheckedUpdateWithoutCursosActivosInput>
    create: XOR<SalasCreateWithoutCursosActivosInput, SalasUncheckedCreateWithoutCursosActivosInput>
  }

  export type SalasUpdateWithoutCursosActivosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    localidad?: LocalidadUpdateOneRequiredWithoutSalasInput
  }

  export type SalasUncheckedUpdateWithoutCursosActivosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    localidadId?: IntFieldUpdateOperationsInput | number
  }

  export type AlumnoOnCursoActivoUpsertWithWhereUniqueWithoutCursoActivoInput = {
    where: AlumnoOnCursoActivoWhereUniqueInput
    update: XOR<AlumnoOnCursoActivoUpdateWithoutCursoActivoInput, AlumnoOnCursoActivoUncheckedUpdateWithoutCursoActivoInput>
    create: XOR<AlumnoOnCursoActivoCreateWithoutCursoActivoInput, AlumnoOnCursoActivoUncheckedCreateWithoutCursoActivoInput>
  }

  export type AlumnoOnCursoActivoUpdateWithWhereUniqueWithoutCursoActivoInput = {
    where: AlumnoOnCursoActivoWhereUniqueInput
    data: XOR<AlumnoOnCursoActivoUpdateWithoutCursoActivoInput, AlumnoOnCursoActivoUncheckedUpdateWithoutCursoActivoInput>
  }

  export type AlumnoOnCursoActivoUpdateManyWithWhereWithoutCursoActivoInput = {
    where: AlumnoOnCursoActivoScalarWhereInput
    data: XOR<AlumnoOnCursoActivoUpdateManyMutationInput, AlumnoOnCursoActivoUncheckedUpdateManyWithoutAlumnosInput>
  }

  export type LocalidadOnCursoUpsertWithoutCursosActivosInput = {
    update: XOR<LocalidadOnCursoUpdateWithoutCursosActivosInput, LocalidadOnCursoUncheckedUpdateWithoutCursosActivosInput>
    create: XOR<LocalidadOnCursoCreateWithoutCursosActivosInput, LocalidadOnCursoUncheckedCreateWithoutCursosActivosInput>
  }

  export type LocalidadOnCursoUpdateWithoutCursosActivosInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    curso?: CursoUpdateOneRequiredWithoutLocalidadInput
    localidad?: LocalidadUpdateOneRequiredWithoutCursosInput
  }

  export type LocalidadOnCursoUncheckedUpdateWithoutCursosActivosInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    localidadId?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type AlumnoCreateManyLocalidadInput = {
    id?: number
    nroDocumento: number
    apellido: string
    nombre: string
    fechaNacimiento: Date | string
    email: string
    celular: number
    domicilio: string
    barrio?: string | null
  }

  export type SalasCreateManyLocalidadInput = {
    id?: number
    nombre: string
    descripcion: string
  }

  export type LocalidadOnCursoCreateManyLocalidadInput = {
    cursoId: number
    nombreMostrar: string
    descripcion: string
  }

  export type AlumnoUpdateWithoutLocalidadInput = {
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    cursoActivo?: AlumnoOnCursoActivoUpdateManyWithoutAlumnoInput
  }

  export type AlumnoUncheckedUpdateWithoutLocalidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    cursoActivo?: AlumnoOnCursoActivoUncheckedUpdateManyWithoutAlumnoInput
  }

  export type AlumnoUncheckedUpdateManyWithoutAlumnosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nroDocumento?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    fechaNacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    celular?: IntFieldUpdateOperationsInput | number
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalasUpdateWithoutLocalidadInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    cursosActivos?: CursosActivosUpdateOneWithoutSalaInput
  }

  export type SalasUncheckedUpdateWithoutLocalidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    cursosActivos?: CursosActivosUncheckedUpdateOneWithoutSalaInput
  }

  export type SalasUncheckedUpdateManyWithoutSalasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type LocalidadOnCursoUpdateWithoutLocalidadInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    curso?: CursoUpdateOneRequiredWithoutLocalidadInput
    cursosActivos?: CursosActivosUpdateManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUncheckedUpdateWithoutLocalidadInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    cursosActivos?: CursosActivosUncheckedUpdateManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUncheckedUpdateManyWithoutCursosInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatarioOnCursoCreateManyCursoInput = {
    destinatarioId: number
    descripcion: string
    nombreMostrar: string
  }

  export type LocalidadOnCursoCreateManyCursoInput = {
    localidadId: number
    nombreMostrar: string
    descripcion: string
  }

  export type DestinatarioOnCursoUpdateWithoutCursoInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    destinatario?: DestinatariosUpdateOneRequiredWithoutCursosInput
  }

  export type DestinatarioOnCursoUncheckedUpdateWithoutCursoInput = {
    destinatarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatarioOnCursoUncheckedUpdateManyWithoutDestinatatiosInput = {
    destinatarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type LocalidadOnCursoUpdateWithoutCursoInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    localidad?: LocalidadUpdateOneRequiredWithoutCursosInput
    cursosActivos?: CursosActivosUpdateManyWithoutLocalidadCursoInput
  }

  export type LocalidadOnCursoUncheckedUpdateWithoutCursoInput = {
    localidadId?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    cursosActivos?: CursosActivosUncheckedUpdateManyWithoutLocalidadCursoInput
  }

  export type CursosActivosCreateManyLocalidadCursoInput = {
    id?: number
    nombreMostrar: string
    activo: boolean
    fechaInicio: Date | string
    fechaFin: Date | string
    horario: string
    cupos: number
    descripcion: string
    salaId?: number | null
  }

  export type CursosActivosUpdateWithoutLocalidadCursoInput = {
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sala?: SalasUpdateOneWithoutCursosActivosInput
    alumnos?: AlumnoOnCursoActivoUpdateManyWithoutCursoActivoInput
  }

  export type CursosActivosUncheckedUpdateWithoutLocalidadCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    salaId?: NullableIntFieldUpdateOperationsInput | number | null
    alumnos?: AlumnoOnCursoActivoUncheckedUpdateManyWithoutCursoActivoInput
  }

  export type CursosActivosUncheckedUpdateManyWithoutCursosActivosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: StringFieldUpdateOperationsInput | string
    cupos?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    salaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlumnoOnCursoActivoCreateManyAlumnoInput = {
    cursoActivoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type AlumnoOnCursoActivoUpdateWithoutAlumnoInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    cursoActivo?: CursosActivosUpdateOneRequiredWithoutAlumnosInput
  }

  export type AlumnoOnCursoActivoUncheckedUpdateWithoutAlumnoInput = {
    cursoActivoId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatarioOnCursoCreateManyDestinatarioInput = {
    cursoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type DestinatarioOnCursoUpdateWithoutDestinatarioInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    curso?: CursoUpdateOneRequiredWithoutDestinatatiosInput
  }

  export type DestinatarioOnCursoUncheckedUpdateWithoutDestinatarioInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type DestinatarioOnCursoUncheckedUpdateManyWithoutCursosInput = {
    cursoId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type AlumnoOnCursoActivoCreateManyCursoActivoInput = {
    alumnoId: number
    descripcion: string
    nombreMostrar: string
  }

  export type AlumnoOnCursoActivoUpdateWithoutCursoActivoInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
    alumno?: AlumnoUpdateOneRequiredWithoutCursoActivoInput
  }

  export type AlumnoOnCursoActivoUncheckedUpdateWithoutCursoActivoInput = {
    alumnoId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }

  export type AlumnoOnCursoActivoUncheckedUpdateManyWithoutAlumnosInput = {
    alumnoId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    nombreMostrar?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}